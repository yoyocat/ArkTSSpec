<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>7. Expressions &#8212; ArkTS Specification 1.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=039e1c02" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=def9ab29"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="8. Statements" href="8_statements.html" />
    <link rel="prev" title="6. Contexts and Conversions" href="6_conversions.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="expressions">
<span id="id1"></span><h1><span class="section-number">7. </span>Expressions<a class="headerlink" href="#expressions" title="Permalink to this heading">¶</a></h1>
<p>This chapter describes the meanings of expressions and the rules for the
evaluation of  expressions, except for the expressions related to coroutines
(see <a class="reference internal" href="17_experimental.html#create-and-launch-a-coroutine"><span class="std std-ref">Create and Launch a Coroutine</span></a> for <em>launch</em> expressions, and
<a class="reference internal" href="17_experimental.html#awaiting-a-coroutine"><span class="std std-ref">Awaiting a Coroutine</span></a> for <em>await</em> expressions).</p>
<div class="highlight-abnf notranslate" id="index-0"><div class="highlight"><pre><span></span><span class="nc">expression</span>:
<span class="w">    </span><span class="nc">literal</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">qualifiedName</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">arrayLiteral</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">objectLiteral</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">spreadExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">parenthesizedExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">thisExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">methodCallExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">fieldAccessExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">indexingExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">functionCallExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">newExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">castExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">instanceOfExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">typeOfExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">ensureNotNullishExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">nullishCoalescingExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">unaryExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">multiplicativeExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">additiveExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">shiftExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">relationalExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">equalityExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">bitwiseAndLogicalExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">conditionalAndExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">conditionalOrExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">assignmentExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">conditionalExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">stringInterpolation</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">lambdaExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">dynamicImportExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">launchExpression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">awaitExpression</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>The grammar rules below introduce the productions to be used by other forms
of expression productions:</p>
<div class="highlight-abnf notranslate" id="index-1"><div class="highlight"><pre><span></span><span class="nc">objectReference</span>:
<span class="w">    </span><span class="nc">typeReference</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">super</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span><span class="c1">;</span>

<span class="nc">arguments</span>:
<span class="w">    </span>&#39;<span class="p">(</span>&#39;<span class="w"> </span><span class="nc">argumentSequence</span>?<span class="w"> </span>&#39;<span class="p">)</span>&#39;
<span class="w">    </span><span class="c1">;</span>

<span class="nc">argumentSequence</span>:
<span class="w">    </span><span class="nc">restArgument</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">expression</span><span class="w"> </span><span class="p">(</span>&#39;,&#39;<span class="w"> </span><span class="nc">expression</span><span class="p">)</span><span class="o">*</span><span class="w"> </span><span class="p">(</span>&#39;,&#39;<span class="w"> </span><span class="nc">restArgument</span><span class="p">)</span>?<span class="w"> </span>&#39;,&#39;?
<span class="w">    </span><span class="c1">;</span>

<span class="nc">restArgument</span>:
<span class="w">    </span>&#39;...&#39;?<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>The <em>objectReference</em> refers to class or interface in the first two cases,
and thus allows handling static members. The last case refers to an
instance variable of class or interface type unless the expression within
<em>potentiallyNullishExpression</em> is evaluated to <em>undefined</em>.</p>
<p>The <em>arguments</em> refers to the list of arguments of a call. The last argument
can be prefixed by the spread operator ‘<code class="docutils literal notranslate"><span class="pre">...</span></code>’.</p>
<div class="line-block" id="index-2">
<div class="line"><br /></div>
</div>
<section id="evaluation-of-expressions">
<span id="id2"></span><h2><span class="section-number">7.1. </span>Evaluation of Expressions<a class="headerlink" href="#evaluation-of-expressions" title="Permalink to this heading">¶</a></h2>
<p>The result of a program expression <em>evaluation</em> denotes the following:</p>
<ul class="simple">
<li><p>A variable (the term <em>variable</em> is used here in the general, non-terminological
sense to denote a modifiable lvalue in the left-hand side of an assignment);
or</p></li>
<li><p>A value (results found in all other places).</p></li>
</ul>
<p id="index-3">A variable or a value are equally considered the <em>value of the expression</em>
if such a value is required for further evaluation.</p>
<p>The type of an expression is inferred at compile time (see
<a class="reference internal" href="6_conversions.html#contexts-and-conversions"><span class="std std-ref">Contexts and Conversions</span></a>).</p>
<p>Expressions can contain assignments, increment operators, decrement operators,
method calls, and function calls. The evaluation of an expression can produce
side effects as a result.</p>
<p id="index-4"><em>Constant expressions</em> (see <a class="reference internal" href="#constant-expressions"><span class="std std-ref">Constant Expressions</span></a>) are the expressions
with values that can be determined at compile time.</p>
<div class="line-block" id="index-5">
<div class="line"><br /></div>
</div>
<section id="normal-and-abrupt-completion-of-expression-evaluation">
<span id="id3"></span><h3><span class="section-number">7.1.1. </span>Normal and Abrupt Completion of Expression Evaluation<a class="headerlink" href="#normal-and-abrupt-completion-of-expression-evaluation" title="Permalink to this heading">¶</a></h3>
<p>Every expression in a normal mode of evaluation requires certain computational
steps. The normal modes of evaluation for each kind of expression are described
in the following sections.</p>
<p>An expression evaluation <em>completes normally</em> if all computational steps
are performed without throwing an exception or error.</p>
<p>On the contrary, an expression <em>completes abruptly</em> if the expression
evaluation throws an exception or an error.</p>
<p>The information about the causes of an abrupt completion can be available
in the value attached to the exception or error object.</p>
<p id="index-6">The predefined operators throw runtime errors as follows:</p>
<ul class="simple">
<li><p>If an array reference expression has the <em>null</em> value, then an array
access expression throws <em>NullPointerError</em>.</p></li>
<li><p>If an array reference expression has the <em>null</em> value, then an
<em>indexing expression</em> (see <a class="reference internal" href="#indexing-expression"><span class="std std-ref">Indexing Expression</span></a>) throws
<em>NullPointerError</em>.</p></li>
<li><p>If an array index expression has a value that is negative, greater than,
or equal to the length of the array, then an <em>indexing expression</em> (see
<a class="reference internal" href="#indexing-expression"><span class="std std-ref">Indexing Expression</span></a>) throws <em>ArrayIndexOutOfBoundsError</em>.</p></li>
<li><p>If a cast cannot be performed at runtime, then cast expressions (see
<a class="reference internal" href="#cast-expressions"><span class="std std-ref">Cast Expressions</span></a>) throw <em>ClassCastError</em>.</p></li>
<li><p>If the right-hand operand expression has the zero value, then integer
division (see <a class="reference internal" href="#division"><span class="std std-ref">Division</span></a>), or integer remainder (see <a class="reference internal" href="#remainder"><span class="std std-ref">Remainder</span></a>)
operators throw <em>ArithmeticError</em>.</p></li>
<li><p>If the boxing conversion (see <a class="reference internal" href="6_conversions.html#boxing-conversions"><span class="std std-ref">Boxing Conversions</span></a>)
occurs, then an assignment to an array element of a reference type (see
<a class="reference internal" href="#array-literal"><span class="std std-ref">Array Literal</span></a>), method call expression (see
<a class="reference internal" href="#method-call-expression"><span class="std std-ref">Method Call Expression</span></a>), or prefix/postfix increment/decrement (see
<a class="reference internal" href="#unary-expressions"><span class="std std-ref">Unary Expressions</span></a>) operators throw <em>OutOfMemoryError</em>.</p></li>
<li><p>If the type of an array element is incompatible with the value that
is being assigned, then an assignment to an array element of a
reference type (see <a class="reference internal" href="#array-literal"><span class="std std-ref">Array Literal</span></a>) throws <em>ArrayStoreError</em>.</p></li>
</ul>
<p id="index-7">Possible hard-to-predict and hard-to-handle linkage and virtual machine errors
can cause errors in the course of an expression evaluation.</p>
<p>An abrupt completion of a subexpression evaluation results in the following:</p>
<ul class="simple" id="index-8">
<li><p>Immediate abrupt completion of the expression that contains such a
subexpression (if the evaluation of the entire expression requires
the evaluation of the contained subexpression); and</p></li>
<li><p>Cancellation of all subsequent steps of the normal mode of evaluation.</p></li>
</ul>
<p id="index-9">The terms ‘<em>complete normally</em>’ and ‘<em>complete abruptly</em>’ can also denote
normal and abrupt completion of the execution of statements (see
<a class="reference internal" href="8_statements.html#normal-and-abrupt-statement-execution"><span class="std std-ref">Normal and Abrupt Statement Execution</span></a>). A statement can complete
abruptly for a variety of reasons in addition to an exception or an error
being thrown.</p>
<div class="line-block" id="index-10">
<div class="line"><br /></div>
</div>
</section>
<section id="order-of-expression-evaluation">
<span id="id4"></span><h3><span class="section-number">7.1.2. </span>Order of Expression Evaluation<a class="headerlink" href="#order-of-expression-evaluation" title="Permalink to this heading">¶</a></h3>
<p>The operands of an operator are evaluated from left to right in accordance with
the following rules:</p>
<ul>
<li><p>Any right-hand operand is evaluated only after the full evaluation of the
left-hand operand of a binary operator.</p>
<p>If using a compound-assignment operator (see <a class="reference internal" href="#simple-assignment-operator"><span class="std std-ref">Simple Assignment Operator</span></a>),
the evaluation of the left-hand operand includes the following:</p>
<ul class="simple">
<li><p>Remembering the variable denoted by the left-hand operand;</p></li>
<li><p>Fetching the value of that variable for the subsequent evaluation
of the right-hand operand; and</p></li>
<li><p>Saving such value.</p></li>
</ul>
<p>If the evaluation of the left-hand operand completes abruptly, then no
part of the right-hand operand is evaluated.</p>
</li>
<li><p>Any part of the operation can be executed only after the full evaluation
of every operand of an operator (except conditional operators ‘&amp;&amp;’, ‘||’,
and ‘?:’).</p>
<p>The execution of a binary operator that is an integer division ‘/’ (see
<a class="reference internal" href="#division"><span class="std std-ref">Division</span></a>), or integer remainder ‘%’ (see <a class="reference internal" href="#remainder"><span class="std std-ref">Remainder</span></a>) can
throw <em>ArithmeticError</em> only after the evaluations of both operands
complete normally.</p>
</li>
<li><p>The ArkTS programming language follows the order of evaluation as indicated
explicitly by parentheses, and implicitly by the precedence of operators.
This rule particularly applies for infinity and NaN values of floating-point
calculations.
ArkTS considers integer addition and multiplication as provably associative;
however, floating-point calculations must not be naively reordered because
they are unlikely to be computationally associative (even though they appear
to be mathematically associative).</p></li>
</ul>
<div class="line-block" id="index-11">
<div class="line"><br /></div>
</div>
</section>
<section id="operator-precedence">
<span id="id5"></span><h3><span class="section-number">7.1.3. </span>Operator Precedence<a class="headerlink" href="#operator-precedence" title="Permalink to this heading">¶</a></h3>
<p>The table below summarizes all information on the precedence and
associativity of operators. Each section on a particular operator
also contains detailed information.</p>
<table class="docutils align-default" id="index-12">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Operator</strong></p></th>
<th class="head"><p><strong>Precedence</strong></p></th>
<th class="head"><p><strong>Associativity</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>postfix increment and decrement</p></td>
<td><p><span class="math notranslate nohighlight">\(++ --\)</span></p></td>
<td><p>left to right</p></td>
</tr>
<tr class="row-odd"><td><p>prefix increment and decrement,
unary, typeof</p></td>
<td><p><span class="math notranslate nohighlight">\(++\)</span> <span class="math notranslate nohighlight">\(--\)</span>
<span class="math notranslate nohighlight">\(+\)</span> <span class="math notranslate nohighlight">\(-\)</span> ! ~
typeof</p></td>
<td><p>right to left</p></td>
</tr>
<tr class="row-even"><td><p>multiplicative</p></td>
<td><p><cite>*</cite> / %</p></td>
<td><p>left to right</p></td>
</tr>
<tr class="row-odd"><td><p>additive</p></td>
<td><p><span class="math notranslate nohighlight">\(+\)</span> <span class="math notranslate nohighlight">\(-\)</span></p></td>
<td><p>left to right</p></td>
</tr>
<tr class="row-even"><td><p>cast</p></td>
<td><p>as</p></td>
<td><p>left to right</p></td>
</tr>
<tr class="row-odd"><td><p>shift</p></td>
<td><p>&lt;&lt; &gt;&gt;  &gt;&gt;&gt;</p></td>
<td><p>left to right</p></td>
</tr>
<tr class="row-even"><td><p>relational</p></td>
<td><p>&lt; &gt; &lt;= &gt;= instanceof</p></td>
<td><p>left to right</p></td>
</tr>
<tr class="row-odd"><td><p>equality</p></td>
<td><p>== !=</p></td>
<td><p>left to right</p></td>
</tr>
<tr class="row-even"><td><p>bitwise AND</p></td>
<td><p>&amp;</p></td>
<td><p>left to right</p></td>
</tr>
<tr class="row-odd"><td><p>bitwise exclusive OR</p></td>
<td><p>^</p></td>
<td><p>left to right</p></td>
</tr>
<tr class="row-even"><td><p>bitwise inclusive OR</p></td>
<td><p>|</p></td>
<td><p>left to right</p></td>
</tr>
<tr class="row-odd"><td><p>logical AND</p></td>
<td><p>&amp;&amp;</p></td>
<td><p>left to right</p></td>
</tr>
<tr class="row-even"><td><p>logical OR</p></td>
<td><p>||</p></td>
<td><p>left to right</p></td>
</tr>
<tr class="row-odd"><td><p>null-coalescing</p></td>
<td><p>??</p></td>
<td><p>left to right</p></td>
</tr>
<tr class="row-even"><td><p>ternary</p></td>
<td><p>?:</p></td>
<td><p>right to left</p></td>
</tr>
<tr class="row-odd"><td><p>assignment</p></td>
<td><p>= += <span class="math notranslate nohighlight">\(-=\)</span> %=
<span class="math notranslate nohighlight">\(*=\)</span> <span class="math notranslate nohighlight">\(/=\)</span>
<code class="docutils literal notranslate"><span class="pre">&amp;=</span></code> <code class="docutils literal notranslate"><span class="pre">^=</span></code> <code class="docutils literal notranslate"><span class="pre">|=</span></code>
&lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</p></td>
<td><p>right to left</p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="evaluation-of-arguments">
<span id="id6"></span><h3><span class="section-number">7.1.4. </span>Evaluation of Arguments<a class="headerlink" href="#evaluation-of-arguments" title="Permalink to this heading">¶</a></h3>
<p>An evaluation of arguments always progresses from left to right up to the first
error, or through the end of the expression; i.e., any argument expression is
evaluated after the evaluation of each argument expression to its left
completes normally (including comma-separated argument expressions that appear
within parentheses in method calls, constructor calls, class instance creation
expressions, or function call expressions).</p>
<p>If the left-hand argument expression completes abruptly, then no part of the
right-hand argument expression is evaluated.</p>
<div class="line-block" id="index-13">
<div class="line"><br /></div>
</div>
</section>
<section id="evaluation-of-other-expressions">
<span id="id7"></span><h3><span class="section-number">7.1.5. </span>Evaluation of Other Expressions<a class="headerlink" href="#evaluation-of-other-expressions" title="Permalink to this heading">¶</a></h3>
<p>These general rules cannot cover the order of evaluation of certain expressions
when they from time to time cause exceptional conditions. The order of
evaluation of the following expressions requires specific explanation:</p>
<ul class="simple">
<li><p>Class instance creation expressions (see <a class="reference internal" href="#new-expressions"><span class="std std-ref">New Expressions</span></a>);</p></li>
<li><p>Array creation expressions (see <a class="reference internal" href="17_experimental.html#array-creation-expressions"><span class="std std-ref">Array Creation Expressions</span></a>);</p></li>
<li><p>Indexing expressions (see <a class="reference internal" href="#indexing-expression"><span class="std std-ref">Indexing Expression</span></a>);</p></li>
<li><p>Method call expressions (see <a class="reference internal" href="#method-call-expression"><span class="std std-ref">Method Call Expression</span></a>);</p></li>
<li><p>Assignments involving indexing (see <a class="reference internal" href="#assignment"><span class="std std-ref">Assignment</span></a>);</p></li>
<li><p>Lambda expressions (see <a class="reference internal" href="#lambda-expressions"><span class="std std-ref">Lambda Expressions</span></a>).</p></li>
</ul>
<div class="line-block" id="index-14">
<div class="line"><br /></div>
</div>
</section>
</section>
<section id="literal">
<span id="id8"></span><h2><span class="section-number">7.2. </span>Literal<a class="headerlink" href="#literal" title="Permalink to this heading">¶</a></h2>
<p>Literals (see <a class="reference internal" href="2_lexical.html#literals"><span class="std std-ref">Literals</span></a>) denote fixed and unchanging value. Types of
literals are determined as follows:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Literal</strong></p></th>
<th class="head"><p><strong>Type of Literal Expression</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Integer</p></td>
<td><p><em>int</em> if the value can be represented by
the 32-bit type, otherwise <em>long</em></p></td>
</tr>
<tr class="row-odd"><td><p>Floating-point</p></td>
<td><p><em>double</em>, <em>float</em></p></td>
</tr>
<tr class="row-even"><td><p>Boolean (true, false)</p></td>
<td><p><em>boolean</em></p></td>
</tr>
<tr class="row-odd"><td><p>Char</p></td>
<td><p><em>char</em></p></td>
</tr>
<tr class="row-even"><td><p>String</p></td>
<td><p><em>string</em></p></td>
</tr>
<tr class="row-odd"><td><p>Null (null)</p></td>
<td><p><em>null</em></p></td>
</tr>
<tr class="row-even"><td><p>Undefined (undefined)</p></td>
<td><p><em>undefined</em></p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="qualified-name">
<span id="id9"></span><h2><span class="section-number">7.3. </span>Qualified Name<a class="headerlink" href="#qualified-name" title="Permalink to this heading">¶</a></h2>
<p>A <em>qualifiedName</em> (see <a class="reference internal" href="4_names.html#names"><span class="std std-ref">Names</span></a>) is an expression that consists of
dot-separated names. A <em>qualifiedName</em> that consists of a single identifier
is called a <em>simple name</em>.</p>
<p>A <em>simple name</em> refers to the following:</p>
<ul class="simple">
<li><p>Global entity of the current compilation unit;</p></li>
<li><p>Local variable; or</p></li>
<li><p>Parameter of the surrounding function or method.</p></li>
</ul>
<p>A <em>qualifiedName</em> that is not a <em>simple name</em> refers to the following:</p>
<ul class="simple">
<li><p>Entity imported from some compilation unit, or</p></li>
<li><p>Member of some class or interface.</p></li>
</ul>
<div class="highlight-typescript notranslate" id="index-15"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nx">compilationUnitName</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;someFile&quot;</span>
<span class="linenos"> 2</span>
<span class="linenos"> 3</span><span class="w"> </span><span class="kd">class</span><span class="w"> </span><span class="nx">Type</span><span class="w"> </span><span class="p">{}</span>
<span class="linenos"> 4</span>
<span class="linenos"> 5</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">foo</span><span class="w"> </span><span class="p">(</span><span class="nx">parameter</span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 6</span><span class="w">   </span><span class="kd">let</span><span class="w"> </span><span class="nx">local</span><span class="o">:</span><span class="w"> </span><span class="kt">Type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">parameter</span><span class="w"> </span><span class="cm">/* here &#39;parameter&#39; is the</span>
<span class="linenos"> 7</span><span class="cm">       expression in the form of simple name */</span>
<span class="linenos"> 8</span><span class="w">   </span><span class="nx">local</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">Type</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="cm">/* here &#39;local&#39; is the expression in the</span>
<span class="linenos"> 9</span><span class="cm">       form of simple name */</span>
<span class="linenos">10</span><span class="w">   </span><span class="nx">local</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">compilationUnitName</span><span class="p">.</span><span class="nx">someGlobalVariable</span><span class="w"> </span><span class="cm">/* here qualifiedName</span>
<span class="linenos">11</span><span class="cm">       refers to a global variable imported from some compilation unit */</span>
<span class="linenos">12</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="array-literal">
<span id="id10"></span><h2><span class="section-number">7.4. </span>Array Literal<a class="headerlink" href="#array-literal" title="Permalink to this heading">¶</a></h2>
<p>An <em>array literal</em> is an expression that can be used to create an array, and
to provide some initial values:</p>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">arrayLiteral</span>:
<span class="w">    </span>&#39;<span class="p">[</span>&#39;<span class="w"> </span><span class="nc">expressionSequence</span>?<span class="w"> </span>&#39;<span class="p">]</span>&#39;
<span class="w">    </span><span class="c1">;</span>

<span class="nc">expressionSequence</span>:
<span class="w">    </span><span class="nc">expression</span><span class="w"> </span><span class="p">(</span>&#39;,&#39;<span class="w"> </span><span class="nc">expression</span><span class="p">)</span><span class="o">*</span><span class="w"> </span>&#39;,&#39;?
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>An <em>array literal</em> is a comma-separated list of <em>initializer expressions</em>
enclosed between ‘[’ and ‘]’. A trailing comma after the last expression
in an array literal is ignored:</p>
<div class="highlight-typescript notranslate" id="index-16"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">]</span><span class="w"> </span><span class="c1">// ok</span>
<span class="linenos">2</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">,]</span><span class="w"> </span><span class="c1">// ok, trailing comma is ignored</span>
</pre></div>
</div>
<p>The number of initializer expressions enclosed in braces of the array
initializer determines the length of the array to be constructed.</p>
<p>If sufficient space is allocated for a new array, then a one-dimensional
array of the specified length is created. All elements of the array
are initialized to the values specified by initializer expressions.</p>
<p id="index-17">On the contrary, the evaluation of the array initializer completes abruptly if:</p>
<ul class="simple">
<li><p>The space allocated for the new array is insufficient, and
<em>OutOfMemoryError</em> is thrown; or</p></li>
<li><p>Some initialization expression completes abruptly.</p></li>
</ul>
<p id="index-18">Initializer expressions are executed from left to right. The <em>n</em>’th expression
specifies the value of the <em>n-1</em>’th element of the array.</p>
<p>Array literals can be nested (i.e., the initializer expression that specifies
an array element can be an array literal if that element is of an <em>array</em> type).</p>
<p>The type of an array literal is inferred by the following rules:</p>
<ul class="simple" id="index-19">
<li><p>If the type can be inferred from the context, then the type of an array
literal is the inferred type <em>T</em>[].</p></li>
<li><p>Otherwise, the type is inferred from the types of its elements.</p></li>
</ul>
<div class="line-block" id="index-20">
<div class="line"><br /></div>
</div>
<section id="array-type-inference-from-context">
<span id="id11"></span><h3><span class="section-number">7.4.1. </span>Array Type Inference from Context<a class="headerlink" href="#array-type-inference-from-context" title="Permalink to this heading">¶</a></h3>
<p>The type of an array literal can be inferred from the context, including
explicit type annotation of a variable declaration, left-hand part type
of an assignment, call parameter type, or type of a cast expression:</p>
<div class="highlight-typescript notranslate" id="index-21"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">a</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">]</span><span class="w"> </span><span class="c1">// ok, variable type is used</span>
<span class="linenos"> 2</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">4</span><span class="p">,</span><span class="w"> </span><span class="mf">5</span><span class="p">]</span><span class="w"> </span><span class="c1">// ok, variable type is used</span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">min</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">[])</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 5</span><span class="w">   </span><span class="kd">let</span><span class="w"> </span><span class="nx">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">x</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>
<span class="linenos"> 6</span><span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">v</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">x</span><span class="p">)</span>
<span class="linenos"> 7</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">v</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">m</span><span class="p">)</span>
<span class="linenos"> 8</span><span class="w">       </span><span class="nx">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">v</span>
<span class="linenos"> 9</span><span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="nx">m</span>
<span class="linenos">10</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">11</span><span class="w"> </span><span class="nx">min</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14</span><span class="p">,</span><span class="w"> </span><span class="mf">0.99</span><span class="p">]);</span><span class="w"> </span><span class="c1">// ok, parameter type is used</span>
<span class="linenos">12</span>
<span class="linenos">13</span><span class="w"> </span><span class="c1">// ...</span>
<span class="linenos">14</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="nx">Matrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">number</span><span class="p">[][]</span>
<span class="linenos">15</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">m</span><span class="o">:</span><span class="w"> </span><span class="kt">Matrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[[</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="mf">4</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mf">5</span><span class="p">,</span><span class="w"> </span><span class="mf">6</span><span class="p">]]</span>
</pre></div>
</div>
<p>All valid conversions are applied to the initializer expression, i.e., each
initializer expression type must be compatible (see <a class="reference internal" href="15_semantics.html#type-compatibility"><span class="std std-ref">Type Compatibility</span></a>)
with the array element type. Otherwise, a compile-time error occurs.</p>
<div class="highlight-typescript notranslate" id="index-22"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2</span>
<span class="linenos">2</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">list</span><span class="o">:</span><span class="w"> </span><span class="kt">Object</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">()]</span><span class="w"> </span><span class="c1">// ok</span>
</pre></div>
</div>
<p>In the example above, the first literal and ‘value’ are implicitly boxed
to <em>Number</em>, and the types of a string literal and the instance of type
<em>Error</em> are compatible (see <a class="reference internal" href="15_semantics.html#type-compatibility"><span class="std std-ref">Type Compatibility</span></a>) with Object because
the corresponding classes are inherited from Object.</p>
<p id="index-23">If the type used in the context is a <em>tuple type</em> (see <a class="reference internal" href="3_types.html#tuple-types"><span class="std std-ref">Tuple Types</span></a>),
and types of all literal expressions are compatible with tuple type elements
at respective positions, then the type of the array literal is a tuple type.</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">tuple</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="kt">number</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;hello&quot;</span><span class="p">]</span><span class="w"> </span><span class="c1">// ok</span>
<span class="linenos">2</span>
<span class="linenos">3</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">incorrect</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="kt">number</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">]</span><span class="w"> </span><span class="c1">// compile-time error</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="array-type-inference-from-types-of-elements">
<span id="id12"></span><h3><span class="section-number">7.4.2. </span>Array Type Inference from Types of Elements<a class="headerlink" href="#array-type-inference-from-types-of-elements" title="Permalink to this heading">¶</a></h3>
<p>If the type of an array literal <code class="docutils literal notranslate"><span class="pre">[</span></code> <em>expr</em><sub>1</sub>, … , <em>expr</em><sub>N</sub> <code class="docutils literal notranslate"><span class="pre">]</span></code>
cannot be inferred from the context, then the following algorithm is to be
used to infer it from the initialization expressions:</p>
<ol class="arabic simple">
<li><p>If there is no expression (<em>N == 0</em>), then the type is <em>Object</em>[].</p></li>
<li><p>If the type of the expression cannot be determined, then the type of the
array literal cannot be inferred, and a compile-time error occurs.</p></li>
<li><p>If each initialization expression is of some numeric type, then the
type is <em>number</em>[].</p></li>
<li><p>If all initialization expressions are of the same type <em>T</em>, then the
type is <em>T</em>[].</p></li>
<li><p>Otherwise, the type is constructed as the union type <em>T</em><sub>1</sub> | … |
<em>T</em><sub>N</sub>, where <em>T</em><sub>i</sub> is the type of <em>expr</em><sub>i</sub>.
Union type normalization (see <a class="reference internal" href="3_types.html#union-types-normalization"><span class="std std-ref">Union Types Normalization</span></a>) is applied
to this union type.</p></li>
</ol>
<div class="highlight-typescript notranslate" id="index-24"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="c1">// type is Object[]</span>
<span class="linenos">2</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">]</span><span class="w"> </span><span class="c1">// type is string[]</span>
<span class="linenos">3</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">]</span><span class="w"> </span><span class="c1">// type is number[]</span>
<span class="linenos">4</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">3.14</span><span class="p">]</span><span class="w"> </span><span class="c1">// type is (string | number)[]</span>
<span class="linenos">5</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[()</span><span class="o">:</span><span class="w"> </span><span class="ow">void</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">A</span><span class="p">()]</span><span class="w"> </span><span class="c1">// type is (() =&gt; void | A)[]</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
</section>
<section id="object-literal">
<span id="id13"></span><h2><span class="section-number">7.5. </span>Object Literal<a class="headerlink" href="#object-literal" title="Permalink to this heading">¶</a></h2>
<p>An <em>object literal</em> is an expression that can be used to create a class
instance, and to provide some initial values. In some cases it is more
convenient to use an <em>object literal</em> in place of a class instance creation
expression (see <a class="reference internal" href="#new-expressions"><span class="std std-ref">New Expressions</span></a>):</p>
<div class="highlight-abnf notranslate" id="index-25"><div class="highlight"><pre><span></span><span class="nc">objectLiteral</span>:
<span class="w">   </span>&#39;{&#39;<span class="w"> </span><span class="nc">valueSequence</span>?<span class="w"> </span>&#39;}&#39;
<span class="w">   </span><span class="c1">;</span>

<span class="nc">valueSequence</span>:
<span class="w">   </span><span class="nc">nameValue</span><span class="w"> </span><span class="p">(</span>&#39;,&#39;<span class="w"> </span><span class="nc">nameValue</span><span class="p">)</span><span class="o">*</span><span class="w"> </span>&#39;,&#39;?
<span class="w">   </span><span class="c1">;</span>

<span class="nc">nameValue</span>:
<span class="w">   </span><span class="nc">identifier</span><span class="w"> </span>&#39;:&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">   </span><span class="c1">;</span>
</pre></div>
</div>
<p>An <em>object literal</em> is written as a comma-separated list of <em>name-value pairs</em>
enclosed in curly braces ‘{’ and ‘}’. A trailing comma after the last pair is
ignored. Each <em>name-value pair</em> consists of an identifier and an expression:</p>
<div class="highlight-typescript notranslate" id="index-26"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">class</span><span class="w"> </span><span class="nx">Person</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">2</span><span class="w">   </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;&quot;</span>
<span class="linenos">3</span><span class="w">   </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span>
<span class="linenos">4</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">5</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Person</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Bob&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">25</span><span class="p">}</span>
<span class="linenos">6</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Person</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Alice&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">18</span><span class="p">,</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">//ok, trailing comma is ignored</span>
</pre></div>
</div>
<p>The type of an object literal is always some class <em>C</em> that is inferred from
the context. A type inferred from the context can be either a named class (see
<a class="reference internal" href="#object-literal-of-class-type"><span class="std std-ref">Object Literal of Class Type</span></a>), or an anonymous class created for the
inferred interface type (see <a class="reference internal" href="#object-literal-of-interface-type"><span class="std std-ref">Object Literal of Interface Type</span></a>).</p>
<p>A compile-time error occurs if:</p>
<ul class="simple">
<li><p>The type of an object literal cannot be inferred from the context; or</p></li>
<li><p>The inferred type is not a class or an interface type.</p></li>
</ul>
<div class="highlight-typescript notranslate" id="index-27"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Bob&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">25</span><span class="p">}</span><span class="w"> </span><span class="cm">/* compile-time error, type is</span>
<span class="linenos">2</span><span class="cm">     not inferred */</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<section id="object-literal-of-class-type">
<span id="id14"></span><h3><span class="section-number">7.5.1. </span>Object Literal of Class Type<a class="headerlink" href="#object-literal-of-class-type" title="Permalink to this heading">¶</a></h3>
<p>If the class type <em>C</em> is inferred from the context, then the type of object
literal is <em>C</em>:</p>
<div class="highlight-typescript notranslate" id="index-28"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">class</span><span class="w"> </span><span class="nx">Person</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">2</span><span class="w">   </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;&quot;</span>
<span class="linenos">3</span><span class="w">   </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span>
<span class="linenos">4</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">5</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">foo</span><span class="p">(</span><span class="nx">p</span><span class="o">:</span><span class="w"> </span><span class="kt">Person</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/*some code*/</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">6</span><span class="w"> </span><span class="c1">// ...</span>
<span class="linenos">7</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">p</span><span class="o">:</span><span class="w"> </span><span class="kt">Person</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Bob&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">25</span><span class="p">}</span><span class="w"> </span><span class="cm">/* ok, variable type is</span>
<span class="linenos">8</span><span class="cm">      used */</span>
<span class="linenos">9</span><span class="w"> </span><span class="nx">foo</span><span class="p">({</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Alice&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">18</span><span class="p">})</span><span class="w"> </span><span class="c1">// ok, parameter type is used</span>
</pre></div>
</div>
<p>An identifier in each <em>name-value pair</em> must name a field of the class <em>C</em>,
or a field of any superclass of class <em>C</em>.</p>
<p>A compile-time error occurs if the identifier does not name an <em>accessible
member field</em> (<a class="reference internal" href="4_names.html#scopes"><span class="std std-ref">Scopes</span></a>) in the type <em>C</em>:</p>
<div class="highlight-typescript notranslate" id="index-29"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">class</span><span class="w"> </span><span class="nx">Friend</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">2</span><span class="w">   </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;&quot;</span>
<span class="linenos">3</span><span class="w">   </span><span class="k">private</span><span class="w"> </span><span class="nx">nick</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;&quot;</span>
<span class="linenos">4</span><span class="w">   </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span>
<span class="linenos">5</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">6</span><span class="w"> </span><span class="c1">// compile-time error, nick is private:</span>
<span class="linenos">7</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">f</span><span class="o">:</span><span class="w"> </span><span class="kt">Friend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;aa&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">55</span><span class="p">,</span><span class="w"> </span><span class="nx">nick</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;bb&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p>A compile-time error occurs if the type of an expression in a <em>name-value
pair</em> is not compatible (see <a class="reference internal" href="15_semantics.html#type-compatibility"><span class="std std-ref">Type Compatibility</span></a>) with the field type:</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">f</span><span class="o">:</span><span class="w"> </span><span class="kt">Friend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="kt">123</span><span class="w"> </span><span class="cm">/* compile-time error - type of right hand-side</span>
<span class="linenos">2</span><span class="cm"> is not compatible to the type of the left hand-side */</span>
</pre></div>
</div>
<p>If class <em>C</em> is to be used in an object literal, then it must have a
<em>parameterless</em> constructor (explicit or default) that is <em>accessible</em>
in the class composite context.</p>
<p>A compile-time error occurs if:</p>
<ul class="simple">
<li><p><em>C</em> does not contain a parameterless constructor; or</p></li>
<li><p>No constructor is accessible.</p></li>
</ul>
<p>This is presented in the examples below:</p>
<div class="highlight-typescript notranslate" id="index-30"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">class</span><span class="w"> </span><span class="nx">C</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">2</span><span class="w">   </span><span class="kr">constructor</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="linenos">3</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">4</span><span class="w"> </span><span class="c1">// ...</span>
<span class="linenos">5</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">c</span><span class="o">:</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="cm">/* compile-time error - no parameterless</span>
<span class="linenos">6</span><span class="cm">        constructor */</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">class</span><span class="w"> </span><span class="nx">C</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">2</span><span class="w">   </span><span class="k">private</span><span class="w"> </span><span class="kr">constructor</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="linenos">3</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">4</span><span class="w"> </span><span class="c1">// ...</span>
<span class="linenos">5</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">c</span><span class="o">:</span><span class="w"> </span><span class="kt">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="cm">/* compile-time error - constructor is not</span>
<span class="linenos">6</span><span class="cm">     accessible */</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="object-literal-of-interface-type">
<span id="id15"></span><h3><span class="section-number">7.5.2. </span>Object Literal of Interface Type<a class="headerlink" href="#object-literal-of-interface-type" title="Permalink to this heading">¶</a></h3>
<p>If the interface type <em>I</em> is inferred from the context, then the type of the
object literal is an anonymous class implicitly created for interface <em>I</em>:</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="nx">Person</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">2</span><span class="w">   </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span>
<span class="linenos">3</span><span class="w">   </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span>
<span class="linenos">4</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">5</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Person</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Bob&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">25</span><span class="p">}</span>
</pre></div>
</div>
<p>In this example, the type of <em>b</em> is an anonymous class that contains the
same fields as the interface <em>I</em>.</p>
<p>The interface type <em>I</em> must contain fields only. A compile-time error occurs
if the interface type <em>I</em> contains a method:</p>
<div class="highlight-typescript notranslate" id="index-31"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="nx">I</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">2</span><span class="w">   </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;&quot;</span>
<span class="linenos">3</span><span class="w">   </span><span class="nx">foo</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="ow">void</span>
<span class="linenos">4</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">5</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Bob&quot;</span><span class="p">}</span><span class="w"> </span><span class="c1">// compile-time error, interface has methods</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="object-literal-of-record-type">
<span id="id16"></span><h3><span class="section-number">7.5.3. </span>Object Literal of Record Type<a class="headerlink" href="#object-literal-of-record-type" title="Permalink to this heading">¶</a></h3>
<p>Generic type <em>Record&lt;Key, Value&gt;</em> (see <a class="reference internal" href="5_generics.html#record-utility-type"><span class="std std-ref">Record Utility Type</span></a>) is used
to map the properties of a type (<em>Key</em> type) to another type (<em>Value</em> type).
A special form of an object literal is used to initialize the value of such
type:</p>
<div class="highlight-abnf notranslate" id="index-32"><div class="highlight"><pre><span></span><span class="nc">recordLiteral</span>:
<span class="w">   </span>&#39;{&#39;<span class="w"> </span><span class="nc">keyValueSequence</span>?<span class="w"> </span>&#39;}&#39;
<span class="w">   </span><span class="c1">;</span>

<span class="nc">keyValueSequence</span>:
<span class="w">   </span><span class="nc">keyValue</span><span class="w"> </span><span class="p">(</span>&#39;,&#39;<span class="w"> </span><span class="nc">keyValue</span><span class="p">)</span><span class="o">*</span><span class="w"> </span>&#39;,&#39;?
<span class="w">   </span><span class="c1">;</span>

<span class="nc">keyValue</span>:
<span class="w">   </span><span class="nc">expression</span><span class="w"> </span>&#39;:&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">   </span><span class="c1">;</span>
</pre></div>
</div>
<p>The first expression in <em>keyValue</em> denotes a key, and must be of type <em>Key</em>;
the second expression denotes a value, and must be of type <em>Value</em>:</p>
<div class="highlight-typescript notranslate" id="index-33"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">map</span><span class="o">:</span><span class="w"> </span><span class="kt">Record</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">number</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="s2">&quot;John&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">25</span><span class="p">,</span>
<span class="w">    </span><span class="s2">&quot;Mary&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">21</span><span class="p">,</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">map</span><span class="p">[</span><span class="s2">&quot;John&quot;</span><span class="p">])</span><span class="w"> </span><span class="c1">// prints 25</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kd">interface</span><span class="w"> </span><span class="nx">PersonInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span>
<span class="w">    </span><span class="nx">salary</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span>
<span class="p">}</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">map</span><span class="o">:</span><span class="w"> </span><span class="kt">Record</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">PersonInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="s2">&quot;John&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">25</span><span class="p">,</span><span class="w"> </span><span class="nx">salary</span><span class="o">:</span><span class="w"> </span><span class="kt">10</span><span class="p">},</span>
<span class="w">    </span><span class="s2">&quot;Mary&quot;</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">21</span><span class="p">,</span><span class="w"> </span><span class="nx">salary</span><span class="o">:</span><span class="w"> </span><span class="kt">20</span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If a key is a union type consisting of literals, then all variants must be
listed in the object literal. Otherwise, a compile-time error occurs:</p>
<div class="highlight-typescript notranslate" id="index-34"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">map</span><span class="o">:</span><span class="w"> </span><span class="kt">Record</span><span class="o">&lt;</span><span class="s2">&quot;aa&quot;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s2">&quot;bb&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">number</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="s2">&quot;aa&quot;</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// compile-time error: &quot;bb&quot; key is missing</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="object-literal-evaluation">
<span id="id17"></span><h3><span class="section-number">7.5.4. </span>Object Literal Evaluation<a class="headerlink" href="#object-literal-evaluation" title="Permalink to this heading">¶</a></h3>
<p>The evaluation of an object literal of type <em>C</em> (where <em>C</em> is either
a named class type or an anonymous class type created for the interface)
is to be performed by the following steps:</p>
<ul class="simple">
<li><p>A parameterless constructor is executed to produce an instance <em>x</em> of
the class <em>C</em>. The execution of the object literal completes abruptly
if so does the execution of the constructor.</p></li>
<li><p>Name-value pairs of the object literal are then executed from left to
right in the textual order they occur in the source code. The execution
of a name-value pair includes the following:</p>
<ul>
<li><p>Evaluation of the expression; and</p></li>
<li><p>Assigning the value of the expression to the corresponding field
of <em>x</em>.</p></li>
</ul>
</li>
</ul>
<p id="index-35">The execution of the object literal completes abruptly if so does
the execution of a name-value pair.</p>
<p>The object literal completes normally with the value of the newly
initialized class instance if so do all name-value pairs.</p>
<div class="line-block" id="index-36">
<div class="line"><br /></div>
</div>
</section>
</section>
<section id="spread-expression">
<span id="id18"></span><h2><span class="section-number">7.6. </span>Spread Expression<a class="headerlink" href="#spread-expression" title="Permalink to this heading">¶</a></h2>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">spreadExpression</span>:
<span class="w">    </span>&#39;...&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>A <em>spread expression</em> can be used only within the array literal (see
<a class="reference internal" href="#array-literal"><span class="std std-ref">Array Literal</span></a>) or argument passing. The <em>expression</em> must be of
array type (see <a class="reference internal" href="3_types.html#array-types"><span class="std std-ref">Array Types</span></a>). Otherwise, a compile-time error occurs.</p>
<p>A <em>spread expression</em> for arrays can be evaluated as follows:</p>
<ul class="simple">
<li><p>At compilation time by the compiler if <em>expression</em> is constant (see
<a class="reference internal" href="#constant-expressions"><span class="std std-ref">Constant Expressions</span></a>);</p></li>
<li><p>During program execution otherwise.</p></li>
</ul>
<p>An array referred by the <em>expression</em> is broken by the evaluation into a
sequence of values. This sequence is used where a spread expression is used.
It can be an assignment, a call of a function, or a method.</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">array1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">]</span>
<span class="linenos"> 2</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">array2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">4</span><span class="p">,</span><span class="w"> </span><span class="mf">5</span><span class="p">]</span>
<span class="linenos"> 3</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">array3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[...</span><span class="nx">array1</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="nx">array2</span><span class="p">]</span><span class="w"> </span><span class="c1">// spread array1 and array2 elements</span>
<span class="linenos"> 4</span><span class="w">    </span><span class="c1">// while building new array literal during compile-time</span>
<span class="linenos"> 5</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">array3</span><span class="p">)</span><span class="w"> </span><span class="c1">// prints [1, 2, 3, 4, 5]</span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="w"> </span><span class="nx">foo</span><span class="w"> </span><span class="p">(...</span><span class="nx">array2</span><span class="p">)</span><span class="w">  </span><span class="c1">// spread array2 elements into arguments of the foo() call</span>
<span class="linenos"> 8</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">foo</span><span class="w"> </span><span class="p">(</span><span class="nx">...array</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 9</span><span class="w">   </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="w"> </span><span class="p">(</span><span class="nx">array</span><span class="p">)</span>
<span class="linenos">10</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="w"> </span><span class="nx">run_time_spread_application</span><span class="w"> </span><span class="p">(</span><span class="nx">array1</span><span class="p">,</span><span class="w"> </span><span class="nx">array2</span><span class="p">)</span><span class="w"> </span><span class="c1">// prints [1, 2, 3, 666, 4, 5]</span>
<span class="linenos">13</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">run_time_spread_application</span><span class="w"> </span><span class="p">(</span><span class="nx">a1</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">[],</span><span class="w"> </span><span class="nx">a2</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">14</span><span class="w">   </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="w"> </span><span class="p">([...</span><span class="nx">a1</span><span class="p">,</span><span class="w"> </span><span class="mf">666</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="nx">a2</span><span class="p">])</span>
<span class="linenos">15</span><span class="w">     </span><span class="c1">// array literal will be built at runtime</span>
<span class="linenos">16</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p><strong>Note</strong>: If an array is spread while calling a function, an appropriate
parameter must be of spread array kind. A compile-time error occurs if an
array is spread into a sequence of ordinary parameters:</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">an_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">]</span>
<span class="linenos">2</span><span class="w"> </span><span class="nx">bar</span><span class="w"> </span><span class="p">(...</span><span class="nx">an_array</span><span class="p">)</span><span class="w"> </span><span class="c1">// compile-time error</span>
<span class="linenos">3</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">bar</span><span class="w"> </span><span class="p">(</span><span class="nx">n1</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">,</span><span class="w"> </span><span class="nx">n2</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="parenthesized-expression">
<span id="id19"></span><h2><span class="section-number">7.7. </span>Parenthesized Expression<a class="headerlink" href="#parenthesized-expression" title="Permalink to this heading">¶</a></h2>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">parenthesizedExpression</span>:
<span class="w">    </span>&#39;<span class="p">(</span>&#39;<span class="w"> </span><span class="nc">expression</span><span class="w"> </span>&#39;<span class="p">)</span>&#39;
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>The type and the value of a parenthesized expression are the same as those of
the contained expression.</p>
<div class="line-block" id="index-37">
<div class="line"><br /></div>
</div>
</section>
<section id="this-expression">
<span id="id20"></span><h2><span class="section-number">7.8. </span><code class="docutils literal notranslate"><span class="pre">this</span></code> Expression<a class="headerlink" href="#this-expression" title="Permalink to this heading">¶</a></h2>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">thisExpression</span>:
<span class="w">    </span>&#39;<span class="nc">this</span>&#39;
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>The keyword <code class="docutils literal notranslate"><span class="pre">this</span></code> can be used as an expression only in the body of an
instance method of a class, <em>enum</em>, or interface.</p>
<p>It can be used in a lambda expression only if it is allowed in the
context the lambda expression appears in.</p>
<p>The keyword <code class="docutils literal notranslate"><span class="pre">this</span></code> in a direct call expression <em>this(…)</em> can only
be used in the explicit constructor call statement.</p>
<p>A compile-time error occurs if the keyword <code class="docutils literal notranslate"><span class="pre">this</span></code> appears elsewhere.</p>
<p id="index-38">The keyword <code class="docutils literal notranslate"><span class="pre">this</span></code> used as a primary expression denotes a value that is a
reference to the following:</p>
<ul class="simple">
<li><p>Object for which the instance method is called; or</p></li>
<li><p>Object being constructed.</p></li>
</ul>
<p>The value denoted by <code class="docutils literal notranslate"><span class="pre">this</span></code> in a lambda body and in the surrounding context
is the same.</p>
<p>The class of the actual object referred to at runtime can be <em>T</em> if <em>T</em>
is a class type, or a class that is a subtype of <em>T</em>.</p>
<div class="line-block" id="index-39">
<div class="line"><br /></div>
</div>
</section>
<section id="field-access-expressions">
<span id="id21"></span><h2><span class="section-number">7.9. </span>Field Access Expressions<a class="headerlink" href="#field-access-expressions" title="Permalink to this heading">¶</a></h2>
<p>A <em>field access expression</em> can access a field of an object that is referred to
by the value of the object reference. The object reference value can have
different forms described in detail in <a class="reference internal" href="#accessing-current-object-fields"><span class="std std-ref">Accessing Current Object Fields</span></a>
and <a class="reference internal" href="#accessing-superclass-fields"><span class="std std-ref">Accessing Superclass Fields</span></a>.</p>
<div class="highlight-abnf notranslate" id="index-40"><div class="highlight"><pre><span></span><span class="nc">fieldAccessExpression</span>:
<span class="w">    </span><span class="nc">objectReference</span><span class="w"> </span><span class="p">(</span>&#39;.&#39;<span class="w"> </span>|<span class="w"> </span>&#39;?.&#39;<span class="p">)</span><span class="w"> </span><span class="nc">identifier</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>This object reference cannot denote a package, class type, or interface type.</p>
<p>Otherwise, the meaning of that expression is determined by the same rules as
the meanings of qualified names.</p>
<p>A field access that contains ‘?.’ (see <a class="reference internal" href="#chaining-operator"><span class="std std-ref">Chaining Operator</span></a>)
is called <em>safe field access</em> because it handles nullish values safely.</p>
<p>If object reference evaluation completes abruptly, then so does the entire
field access expression.</p>
<div class="line-block" id="index-41">
<div class="line"><br /></div>
</div>
<section id="accessing-current-object-fields">
<span id="id22"></span><h3><span class="section-number">7.9.1. </span>Accessing Current Object Fields<a class="headerlink" href="#accessing-current-object-fields" title="Permalink to this heading">¶</a></h3>
<p>An object reference used for Field Access must be a non-nullish reference
type <em>T</em>. Otherwise, a compile-time error occurs.</p>
<p>Field access expression is valid if the identifier refers to a single
accessible member field in type <em>T</em>.</p>
<p>A compile-time error occurs if:</p>
<ul class="simple">
<li><p>The identifier names several accessible member fields (see <a class="reference internal" href="4_names.html#scopes"><span class="std std-ref">Scopes</span></a>)
in type <em>T</em>.</p></li>
<li><p>The identifier does not name an accessible member field in type <em>T</em>.</p></li>
</ul>
<p id="index-42">The result of the field access expression is computed at runtime as follows:</p>
<ol class="loweralpha simple">
<li><p>For a <em>static</em> field:</p></li>
</ol>
<p>The result of an <em>object reference expression</em> evaluation is discarded.</p>
<p>The result of the <em>field access expression</em> is <em>value</em> or <em>variable</em>
of the static field in the class or interface that is the type
of the <em>object reference expression</em>:</p>
<ul class="simple">
<li><p>If the field is not <em>readonly</em>, then the result is <em>variable</em>,
and its value can be changed.</p></li>
<li><p>If the field is <em>readonly</em>, then the result is <em>value</em> (except where the
<em>field access</em> occurs in a class initializer, see <a class="reference internal" href="9_classes.html#class-initializer"><span class="std std-ref">Class Initializer</span></a>).</p></li>
</ul>
<ol class="loweralpha simple" id="index-43" start="2">
<li><p>For a non-<em>static</em> field:</p></li>
</ol>
<p>The object reference expression is evaluated.</p>
<p>The result of the <em>field access expression</em> is <em>value</em> or <em>variable</em>
of the instance field in the class or interface that is the type
of the <em>object reference expression</em>:</p>
<ul class="simple">
<li><p>If the field is not <em>readonly</em>, then the result is <em>variable</em>,
and its value can be changed.</p></li>
<li><p>If the field is <em>readonly</em>, then the result is <em>value</em> (except where the
<em>field access</em> occurs in a constructor, see <a class="reference internal" href="9_classes.html#constructor-declaration"><span class="std std-ref">Constructor Declaration</span></a>).</p></li>
</ul>
<p>Only the object reference type (not the class type of an actual object
referred at runtime) is used to determine the field to be accessed.</p>
<div class="line-block" id="index-44">
<div class="line"><br /></div>
</div>
</section>
<section id="accessing-superclass-fields">
<span id="id23"></span><h3><span class="section-number">7.9.2. </span>Accessing Superclass Fields<a class="headerlink" href="#accessing-superclass-fields" title="Permalink to this heading">¶</a></h3>
<p>A field access expression cannot denote a package, class type, or interface
type. Otherwise, the meaning of that expression is determined by the same
rules as the meaning of a qualified name.</p>
<p>The form <em>super.identifier</em> refers to the field named <em>identifier</em> of the
current object. That current object is viewed as an instance of the
superclass of the current class.</p>
<p>The forms that use the keyword <code class="docutils literal notranslate"><span class="pre">super</span></code> are valid only in:</p>
<ul class="simple">
<li><p>Instance methods;</p></li>
<li><p>Instance initializers;</p></li>
<li><p>Constructors of a class; or</p></li>
<li><p>Initializers of an instance variable of a class.</p></li>
</ul>
<p id="index-45">A compile-time error occurs if forms with the keyword <code class="docutils literal notranslate"><span class="pre">super</span></code>:</p>
<ul class="simple">
<li><p>Occur elsewhere;</p></li>
<li><p>Occur in the declaration of class <em>Object</em> (since <em>Object</em>
has no superclass).</p></li>
</ul>
<p>The field access expression <em>super.f</em> is handled in the same way as the
expression <em>this.f</em> in the body of class <em>S</em>. Assuming that <em>super.f</em>
appears within class <em>C</em>, <em>f</em> is accessible in <em>S</em> from class <em>C</em> (see
<a class="reference internal" href="4_names.html#scopes"><span class="std std-ref">Scopes</span></a>) while:</p>
<ul class="simple">
<li><p>The direct superclass of <em>C</em> is class <em>S</em>;</p></li>
<li><p>The direct superclass of the class denoted by <em>T</em> is a class with <em>S</em>
as its fully qualified name.</p></li>
</ul>
<p>A compile-time error occurs otherwise (particularly if the current class
is not <em>T</em>).</p>
<div class="line-block" id="index-46">
<div class="line"><br /></div>
</div>
</section>
</section>
<section id="method-call-expression">
<span id="id24"></span><h2><span class="section-number">7.10. </span>Method Call Expression<a class="headerlink" href="#method-call-expression" title="Permalink to this heading">¶</a></h2>
<p>A method call expression calls a static or instance method of a class or
an interface.</p>
<div class="highlight-abnf notranslate" id="index-47"><div class="highlight"><pre><span></span><span class="nc">methodCallExpression</span>:
<span class="w">    </span><span class="nc">objectReference</span><span class="w"> </span><span class="p">(</span>&#39;.&#39;<span class="w"> </span>|<span class="w"> </span>&#39;?.<span class="p">)</span><span class="w"> </span><span class="nc">identifier</span><span class="w"> </span><span class="nc">typeArguments</span>?<span class="w"> </span><span class="nc">arguments</span><span class="w"> </span><span class="nc">block</span>?
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>The syntax form that has a block associated with the method call is a special
form called ‘<em>trailing lambda call</em>’ (see <a class="reference internal" href="17_experimental.html#trailing-lambda"><span class="std std-ref">Trailing Lambda</span></a> for details.</p>
<p>A compile-time error occurs if <em>typeArguments</em> is present, and any of type
arguments is a wildcard (see <a class="reference internal" href="5_generics.html#type-arguments"><span class="std std-ref">Type Arguments</span></a>).</p>
<p>A method call with ‘?.’ (see <a class="reference internal" href="#chaining-operator"><span class="std std-ref">Chaining Operator</span></a>) is
called a ‘<em>safe method call</em>’ because it handles nullish values safely.</p>
<p>Resolving a method at compile time is more complicated than resolving a field
because method overloading (see <a class="reference internal" href="17_experimental.html#class-method-overloading"><span class="std std-ref">Class Method Overloading</span></a>) can occur.</p>
<p>There are several steps that determine and check the method to be called at
compile time (see <a class="reference internal" href="#step-1-selection-of-type-to-use"><span class="std std-ref">Step 1: Selection of Type to Use</span></a>,
<a class="reference internal" href="#step-2-selection-of-method"><span class="std std-ref">Step 2: Selection of Method</span></a>, and
<a class="reference internal" href="#step-3-semantic-correctness-check"><span class="std std-ref">Step 3: Semantic Correctness Check</span></a>).</p>
<div class="line-block" id="index-48">
<div class="line"><br /></div>
</div>
<section id="step-1-selection-of-type-to-use">
<span id="id25"></span><h3><span class="section-number">7.10.1. </span>Step 1: Selection of Type to Use<a class="headerlink" href="#step-1-selection-of-type-to-use" title="Permalink to this heading">¶</a></h3>
<p>The object reference and the method identifier are used to determine the
type in which to search the method. The following options must be considered:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Form of object reference</p></th>
<th class="head"><p>Type to use</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>typeReference.identifier</em></p></td>
<td><p>Type denoted by <em>typeReference</em>.</p></td>
</tr>
<tr class="row-odd"><td><p><em>expression.identifier</em>, where
<em>expression</em> is of type <em>T</em></p></td>
<td><p><em>T</em> if <em>T</em> is a class or interface,
<em>T</em>’s constraint
(<a class="reference internal" href="5_generics.html#type-parameter-constraint"><span class="std std-ref">Type Parameter Constraint</span></a>) if <em>T</em> is
a type parameter. A compile-time error occurs
otherwise.</p></td>
</tr>
<tr class="row-even"><td><p><em>super.identifier</em></p></td>
<td><p>The superclass of the class that contains
the method call.</p></td>
</tr>
</tbody>
</table>
<div class="line-block" id="index-49">
<div class="line"><br /></div>
</div>
</section>
<section id="step-2-selection-of-method">
<span id="id26"></span><h3><span class="section-number">7.10.2. </span>Step 2: Selection of Method<a class="headerlink" href="#step-2-selection-of-method" title="Permalink to this heading">¶</a></h3>
<p>After the type to use is known, the call method must be determined.
The goal is to select one from all potentially applicable methods.</p>
<p>As there is more than one applicable method, the <em>most specific</em> method must
be selected. The method selection process results with the set of
applicable methods and is described in <a class="reference internal" href="#function-or-method-selection"><span class="std std-ref">Function or method selection</span></a>.</p>
<p id="index-50">A compile-time error occurs if:</p>
<ul class="simple">
<li><p>The set of applicable methods is empty; or</p></li>
<li><p>The set of applicable methods has more than one candidate.</p></li>
</ul>
<div class="line-block" id="index-51">
<div class="line"><br /></div>
</div>
</section>
<section id="step-3-semantic-correctness-check">
<span id="id27"></span><h3><span class="section-number">7.10.3. </span>Step 3: Semantic Correctness Check<a class="headerlink" href="#step-3-semantic-correctness-check" title="Permalink to this heading">¶</a></h3>
<p>At this step, the single method to call (the <em>most specific</em> method) is known,
and the following set of semantic checks must be performed:</p>
<ul class="simple">
<li><p>If the method call has the form <em>typeReference.identifier</em>, then the method
must be declared <code class="docutils literal notranslate"><span class="pre">static</span></code>. Otherwise, a compile-time error occurs.</p></li>
<li><p>If the method call has the form <em>expression.identifier</em>, then the method
must not be declared <code class="docutils literal notranslate"><span class="pre">static</span></code>. Otherwise, a compile-time error occurs.</p></li>
<li><p>If the method call has the form <em>super.identifier</em>, then the method must
not be declared <code class="docutils literal notranslate"><span class="pre">abstract</span></code>. Otherwise, a compile-time error occurs.</p></li>
<li><p>If the last argument of a method call has the spread operator ‘<code class="docutils literal notranslate"><span class="pre">...</span></code>’,
then <em>objectReference</em> that follows that argument must refer to an array
whose type is compatible (see <a class="reference internal" href="15_semantics.html#type-compatibility"><span class="std std-ref">Type Compatibility</span></a>) with the type
specified in the last parameter of the method declaration.</p></li>
</ul>
<div class="line-block" id="index-52">
<div class="line"><br /></div>
</div>
</section>
<section id="function-or-method-selection">
<span id="id28"></span><h3><span class="section-number">7.10.4. </span>Function or method selection<a class="headerlink" href="#function-or-method-selection" title="Permalink to this heading">¶</a></h3>
<p>The function selection is the process of choosing the functions
or methods that are applicable for the given function or method call.
The choosing algorithm is described below:</p>
<ol class="arabic simple">
<li><p>An empty list of applicable candidates is created.</p></li>
</ol>
<p>2. The argument types are taken from the call and compose the list
TA = ( <em>ta</em><sub>1</sub> , <em>ta</em><sub>2</sub> , … <em>ta</em><sub>n</sub> ) where <em>ta</em><sub>i</sub>
is the type of the <em>i</em>’th argument, and n is the number of the function
or method call arguments.</p>
<p>3. Suppose there is a set of M candidates (functions or methods with
the same name) that are accessible at the point of call.
The following actions are performed for every candidate:</p>
<p>3.1 If the number of parameters if the <em>j</em>’th candidate is not equal to n
then the candidate is excluded from the M set.</p>
<p>3.2 For each candidate from the M set, the following check is performed.
Each type <em>ta</em><sub>i</sub> from the list TA is compared with the type of the
<em>i</em>’th candidate parameter. The comparison is performed using
the rules of type compatibility (see <a class="reference internal" href="15_semantics.html#type-compatibility"><span class="std std-ref">Type Compatibility</span></a>) but without
consideration for possible boxing conversions (see <a class="reference internal" href="6_conversions.html#boxing-conversions"><span class="std std-ref">Boxing Conversions</span></a>)
and unboxing conversions (see <a class="reference internal" href="6_conversions.html#unboxing-conversions"><span class="std std-ref">Unboxing Conversions</span></a>).
Also, no considerations to the rest parameter (see <a class="reference internal" href="4_names.html#rest-parameter"><span class="std std-ref">Rest Parameter</span></a>) and
optional parameters (see <a class="reference internal" href="4_names.html#optional-parameters"><span class="std std-ref">Optional Parameters</span></a>) parameters are performed.</p>
<p>If the candidate satisfies the check, it is added to the list of applicable
candidates.</p>
<p>3.3 After all candidates are considered, and if the list of applicable
candidates is empty then the step 3.2 is performed again. On this step each type
<em>ta</em><sub>i</sub> is compared with the type of the <em>i</em>’th candidate parameter,
and type compatibility rules do consider possible boxing and unboxing conversion.</p>
<p>If the candidate satisfies the check, it is added to the list of applicable
candidates.</p>
<p>If the candidate satisfies the check, it is added to the list of applicable candidates.</p>
<p>3.4 After all candidates are considered, and if the list of applicable candidates
is empty then the step 3.2 is performed again. On this step each type <em>ta</em><sub>i</sub>
is compared with the type of the <em>i</em>’th candidate parameter, and type
compatibility rules do consider possible boxing and unboxing conversion as well as
rest and optional parameters.</p>
<p>The list of applicable candidates is ready.</p>
<p>Examples:</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kd">class</span><span class="w"> </span><span class="nx">Base</span><span class="w"> </span><span class="p">{}</span>
<span class="linenos"> 2</span><span class="kd">class</span><span class="w"> </span><span class="nx">Derived</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nx">Base</span><span class="w"> </span><span class="p">{}</span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="nx">foo</span><span class="w"> </span><span class="p">(</span><span class="nx">p</span><span class="o">:</span><span class="w"> </span><span class="kt">Base</span><span class="p">)</span>
<span class="linenos"> 5</span><span class="nx">foo</span><span class="w"> </span><span class="p">(</span><span class="nx">p</span><span class="o">:</span><span class="w"> </span><span class="kt">Derived</span><span class="p">)</span>
<span class="linenos"> 6</span><span class="nx">foo</span><span class="w"> </span><span class="p">(</span><span class="ow">new</span><span class="w"> </span><span class="nx">Derived</span><span class="p">)</span><span class="w"> </span><span class="c1">// two applicable candidates for this call</span>
<span class="linenos"> 7</span>
<span class="linenos"> 8</span><span class="nx">foo</span><span class="w"> </span><span class="p">(</span><span class="nx">p</span><span class="o">:</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">B</span><span class="p">)</span>
<span class="linenos"> 9</span><span class="nx">foo</span><span class="w"> </span><span class="p">(</span><span class="nx">p</span><span class="o">:</span><span class="w"> </span><span class="kt">A</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">C</span><span class="p">)</span>
<span class="linenos">10</span><span class="nx">foo</span><span class="p">(</span><span class="ow">new</span><span class="w"> </span><span class="nx">A</span><span class="p">)</span><span class="w"> </span><span class="c1">// two applicable candidates for this call</span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="nx">foo</span><span class="w"> </span><span class="p">(</span><span class="nx">p1</span><span class="o">:</span><span class="w"> </span><span class="kt">Base</span><span class="p">)</span>
<span class="linenos">13</span><span class="nx">foo</span><span class="w"> </span><span class="p">(</span><span class="nx">p2</span><span class="o">:</span><span class="w"> </span><span class="kt">Base</span><span class="o">|</span><span class="nx">SomeOtherType</span><span class="p">)</span>
<span class="linenos">14</span><span class="nx">foo</span><span class="w"> </span><span class="p">(</span><span class="nx">...p3</span><span class="o">:</span><span class="w"> </span><span class="kt">Base</span><span class="p">[])</span>
<span class="linenos">15</span><span class="nx">foo</span><span class="w"> </span><span class="p">(</span><span class="ow">new</span><span class="w"> </span><span class="nx">Base</span><span class="p">)</span><span class="w"> </span><span class="c1">// three applicable candidates for this call</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
</section>
<section id="function-call-expression">
<span id="id29"></span><h2><span class="section-number">7.11. </span>Function Call Expression<a class="headerlink" href="#function-call-expression" title="Permalink to this heading">¶</a></h2>
<p>A <em>function call expression</em> is used to call a function (see
<a class="reference internal" href="3_types.html#function-types"><span class="std std-ref">Function Types</span></a>) or a lambda expression (see <a class="reference internal" href="#lambda-expressions"><span class="std std-ref">Lambda Expressions</span></a>):</p>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">functionCallExpression</span>:
<span class="w">    </span><span class="nc">expression</span><span class="w"> </span><span class="p">(</span>&#39;?.&#39;<span class="w"> </span>|<span class="w"> </span><span class="nc">typeArguments</span><span class="p">)</span>?<span class="w"> </span><span class="nc">arguments</span><span class="w"> </span><span class="nc">block</span>?
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>A special syntactic form that contains a block associated with the function
call is called ‘<em>trailing lambda call</em>’ (see <a class="reference internal" href="17_experimental.html#trailing-lambda"><span class="std std-ref">Trailing Lambda</span></a> for
details).</p>
<p>A compile-time error occurs if:</p>
<ul class="simple">
<li><p>The <em>typeArguments</em> clause is present, and any of the type arguments is a
wildcard (see <a class="reference internal" href="5_generics.html#type-arguments"><span class="std std-ref">Type Arguments</span></a>).</p></li>
<li><p>The <em>expression</em> type is different than the function type.</p></li>
<li><p>The <em>expression</em> type is nullish but no ‘?.’ (see <a class="reference internal" href="#chaining-operator"><span class="std std-ref">Chaining Operator</span></a>)
is present.</p></li>
</ul>
<p id="index-53">If the operator ‘?.’ (see <a class="reference internal" href="#chaining-operator"><span class="std std-ref">Chaining Operator</span></a>) is present, and the
<em>expression</em> evaluates to a nullish value, then:</p>
<ul class="simple">
<li><p>The <em>arguments</em> are not evaluated;</p></li>
<li><p>The call is not performed; and</p></li>
<li><p>The result of the <em>functionCallExpression</em> is <em>undefined</em>.</p></li>
</ul>
<p>The function call is <em>safe</em> because it handles nullish values properly.</p>
<p><a class="reference internal" href="#step-1-selection-of-function"><span class="std std-ref">Step 1: Selection of Function</span></a> and <a class="reference internal" href="#step-2-semantic-correctness-check"><span class="std std-ref">Step 2: Semantic Correctness Check</span></a>
below specify the steps to follow to determine what function is being called.</p>
<div class="line-block" id="index-54">
<div class="line"><br /></div>
</div>
<section id="step-1-selection-of-function">
<span id="id30"></span><h3><span class="section-number">7.11.1. </span>Step 1: Selection of Function<a class="headerlink" href="#step-1-selection-of-function" title="Permalink to this heading">¶</a></h3>
<p>One function must be selected from all potentially applicable functions as a
function can be overloaded.</p>
<p>The <em>most specific</em> function must be selected where there are more than one
applicable functions.</p>
<p>The function selection process results with the set of applicable functions
and is described in <a class="reference internal" href="#function-or-method-selection"><span class="std std-ref">Function or method selection</span></a>.</p>
<p id="index-55">A compile-time error occurs if:</p>
<ul class="simple">
<li><p>The set of applicable function is empty; or</p></li>
<li><p>The set of applicable functions has more than one candidate.</p></li>
</ul>
<div class="line-block" id="index-56">
<div class="line"><br /></div>
</div>
</section>
<section id="step-2-semantic-correctness-check">
<span id="id31"></span><h3><span class="section-number">7.11.2. </span>Step 2: Semantic Correctness Check<a class="headerlink" href="#step-2-semantic-correctness-check" title="Permalink to this heading">¶</a></h3>
<p>The single function to call is known at this step. The following semantic
check must be performed:</p>
<p>If the last argument of the function call has the spread operator ‘<code class="docutils literal notranslate"><span class="pre">...</span></code>’,
then <em>objectReference</em> that follows the argument must refer to an array
of a type compatible with that specified in the last parameter of the
function declaration (see <a class="reference internal" href="15_semantics.html#type-compatibility"><span class="std std-ref">Type Compatibility</span></a>).</p>
<div class="line-block" id="index-57">
<div class="line"><br /></div>
</div>
</section>
</section>
<section id="indexing-expression">
<span id="id32"></span><h2><span class="section-number">7.12. </span>Indexing Expression<a class="headerlink" href="#indexing-expression" title="Permalink to this heading">¶</a></h2>
<p>An indexing expression is used to access elements of arrays (see
<a class="reference internal" href="3_types.html#array-types"><span class="std std-ref">Array Types</span></a>) and <em>Record</em> instances (see <a class="reference internal" href="5_generics.html#record-utility-type"><span class="std std-ref">Record Utility Type</span></a>). It
can also be applied to instances of indexable types (see <a class="reference internal" href="17_experimental.html#indexable-types"><span class="std std-ref">Indexable Types</span></a>):</p>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">indexingExpression</span>:
<span class="w">    </span><span class="nc">expression</span><span class="w"> </span><span class="p">(</span>&#39;?.&#39;<span class="p">)</span>?<span class="w"> </span>&#39;<span class="p">[</span>&#39;<span class="w"> </span><span class="nc">expression</span><span class="w"> </span>&#39;<span class="p">]</span>&#39;
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>An indexing expression contains two subexpressions as follows:</p>
<ul class="simple">
<li><p><em>Object reference expression</em> before the left bracket; and</p></li>
<li><p><em>Index expression</em> inside the brackets.</p></li>
</ul>
<p id="index-58">If ‘?.’ (see <a class="reference internal" href="#chaining-operator"><span class="std std-ref">Chaining Operator</span></a>) is present in an indexing expression,
then:</p>
<ul class="simple">
<li><p>The type of the object reference expression must be a nullish type based
on an array type or on the <em>Record</em> type. Otherwise, a compile-time error
occurs.</p></li>
<li><p>The object reference expression must be checked to evaluate to nullish
value. If it does, then the entire <em>indexingExpression</em> equals <em>undefined</em>.</p></li>
</ul>
<p>If no ‘?.’ is present in an indexing expression, then object reference
expression must be an array type or the <em>Record</em> type. Otherwise, a
compile-time error occurs.</p>
<div class="line-block" id="index-59">
<div class="line"><br /></div>
</div>
<section id="array-indexing-expression">
<span id="id33"></span><h3><span class="section-number">7.12.1. </span>Array Indexing Expression<a class="headerlink" href="#array-indexing-expression" title="Permalink to this heading">¶</a></h3>
<p>For array indexing, the <em>index expression</em> must be of a numeric type.</p>
<p>If the type of <em>index expression</em> is <em>number</em> or other floating-point type,
and its fractional part is different from 0, then errors occur as follows:</p>
<ul class="simple">
<li><p>Runtime error, if the situation is identified during program execution; and</p></li>
<li><p>Compile-time error, if the situation is detected during compilation.</p></li>
</ul>
<p>A numeric types conversion (see <a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a>) is
performed on <em>index expression</em> to ensure that the resultant type is <em>int</em>.
Otherwise, a compile-time error occurs.</p>
<p>If the type of <em>object reference expression</em> after applying of the chaining
operator ‘?.’ (see <a class="reference internal" href="#chaining-operator"><span class="std std-ref">Chaining Operator</span></a>) is an array type <em>T</em>[], then the
type of the indexing expression is <em>T</em>.</p>
<p>The result of an indexing expression is a variable of type <em>T</em> (i.e., a
variable within the array selected by the value of that <em>index expression</em>).</p>
<p>It is essential that, if type <em>T</em> is a reference type, then the fields of array
elements can be modified by changing the resultant variable fields:</p>
<div class="line-block" id="index-60">
<div class="line"><br /></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">names</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;Alice&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Bob&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Carol&quot;</span><span class="p">]</span>
<span class="linenos"> 2</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">[</span><span class="mf">1</span><span class="p">])</span><span class="w"> </span><span class="c1">// prints Bob</span>
<span class="linenos"> 3</span><span class="w"> </span><span class="kt">string</span><span class="p">[</span><span class="mf">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;Martin&quot;</span>
<span class="linenos"> 4</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">[</span><span class="mf">1</span><span class="p">])</span><span class="w"> </span><span class="c1">// prints Martin</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="w"> </span><span class="kd">class</span><span class="w"> </span><span class="nx">RefType</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 7</span><span class="w">     </span><span class="nx">field</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">666</span>
<span class="linenos"> 8</span><span class="w"> </span><span class="p">}</span>
<span class="linenos"> 9</span><span class="w"> </span><span class="kd">const</span><span class="w"> </span><span class="nx">objects</span><span class="o">:</span><span class="w"> </span><span class="kt">RefType</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="ow">new</span><span class="w"> </span><span class="nx">RefType</span><span class="p">(),</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">RefType</span><span class="p">()]</span>
<span class="linenos">10</span><span class="w"> </span><span class="kd">const</span><span class="w"> </span><span class="nx">object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">objects</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">]</span>
<span class="linenos">11</span><span class="w"> </span><span class="nx">object</span><span class="p">.</span><span class="nx">field</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">777</span><span class="w">            </span><span class="c1">// change the field in the array element</span>
<span class="linenos">12</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">objects</span><span class="p">[</span><span class="mf">0</span><span class="p">].</span><span class="nx">filed</span><span class="p">)</span><span class="w"> </span><span class="c1">// prints 666</span>
<span class="linenos">13</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">objects</span><span class="p">[</span><span class="mf">1</span><span class="p">].</span><span class="nx">filed</span><span class="p">)</span><span class="w"> </span><span class="c1">// prints 777</span>
<span class="linenos">14</span>
<span class="linenos">15</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">an_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">]</span>
<span class="linenos">16</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">an_array</span><span class="w"> </span><span class="p">[</span><span class="mf">3.5</span><span class="p">]</span><span class="w"> </span><span class="c1">// Compile-time error</span>
<span class="linenos">17</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">foo</span><span class="w"> </span><span class="p">(</span><span class="nx">index</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">18</span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">an_array</span><span class="w"> </span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
<span class="linenos">19</span><span class="w">       </span><span class="c1">// Runtime-time error if index is not integer</span>
<span class="linenos">20</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>An array indexing expression evaluated at runtime behaves as follows:</p>
<ul class="simple">
<li><p>First, the object reference expression is evaluated.</p></li>
<li><p>If the evaluation completes abruptly, then so does the indexing
expression, and the index expression is not evaluated.</p></li>
<li><p>If the evaluation completes normally, then the index expression is evaluated.
The resultant value of the object reference expression refers to an array.</p></li>
<li><p>If the index expression value of an array is less than zero, greater
than, or equal to the array’s <em>length</em>, then <em>ArrayIndexOutOfBoundsError</em>
is thrown.</p></li>
<li><p>Otherwise, the result of the array access is a type <em>T</em> variable within
the array selected by the value of the index expression.</p></li>
</ul>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">setElement</span><span class="p">(</span><span class="nx">names</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">[],</span><span class="w"> </span><span class="nx">i</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">,</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">2</span><span class="w">     </span><span class="nx">names</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="c1">// run-time error, if &#39;i&#39; is out of bounds</span>
<span class="linenos">3</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<div class="line-block" id="index-61">
<div class="line"><br /></div>
</div>
</section>
<section id="record-indexing-expression">
<span id="id34"></span><h3><span class="section-number">7.12.2. </span>Record Indexing Expression<a class="headerlink" href="#record-indexing-expression" title="Permalink to this heading">¶</a></h3>
<p>For a <em>Record&lt;Key, Value&gt;</em> indexing (see <a class="reference internal" href="5_generics.html#record-utility-type"><span class="std std-ref">Record Utility Type</span></a>),
the <em>index expression</em> must be of type <em>Key</em>.</p>
<p>The following two cases are to be considered separately:</p>
<ol class="arabic simple">
<li><p>Type <em>Key</em> is a union that contains literal types only;</p></li>
<li><p>Other cases.</p></li>
</ol>
<p><strong>Case 1.</strong> If type <em>Key</em> is a union that contains literal types only, then
the <em>index expression</em> can only be one of the literals listed in the type.
The result of an indexing expression is of type <em>Value</em>.</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="nx">Keys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;key1&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;key2&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;key3&#39;</span>
<span class="linenos">2</span>
<span class="linenos">3</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">x</span><span class="o">:</span><span class="w"> </span><span class="kt">Record</span><span class="o">&lt;</span><span class="nx">Keys</span><span class="p">,</span><span class="w"> </span><span class="kt">number</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">4</span><span class="w">     </span><span class="s1">&#39;key1&#39;</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span>
<span class="linenos">5</span><span class="w">     </span><span class="s1">&#39;key2&#39;</span><span class="o">:</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span>
<span class="linenos">6</span><span class="w">     </span><span class="s1">&#39;key3&#39;</span><span class="o">:</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span>
<span class="linenos">7</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">8</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">x</span><span class="p">[</span><span class="s1">&#39;key2&#39;</span><span class="p">]</span><span class="w"> </span><span class="c1">// y value is 2</span>
</pre></div>
</div>
<p>A compile-time error occurs if an index expression is not a valid literal:</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">[</span><span class="s1">&#39;key4&#39;</span><span class="p">])</span><span class="w"> </span><span class="c1">// compile-time error</span>
<span class="linenos">2</span><span class="w"> </span><span class="nx">x</span><span class="p">[</span><span class="s1">&#39;another key&#39;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5</span><span class="w"> </span><span class="c1">// compile-time error</span>
</pre></div>
</div>
<p>For this type <em>Key</em>, the compiler guarantees that an object of
<em>Record&lt;Key, Value&gt;</em> contains values for all <em>Key</em> keys.</p>
<p><strong>Case 2.</strong> There is no restriction on an <em>index expression</em>.
The result of an indexing expression is of type <em>Value | undefined</em>.</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">x</span><span class="o">:</span><span class="w"> </span><span class="kt">Record</span><span class="o">&lt;</span><span class="kt">number</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 2</span><span class="w">     </span><span class="mf">1</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;hello&quot;</span><span class="p">,</span>
<span class="linenos"> 3</span><span class="w">     </span><span class="mf">2</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;buy&quot;</span><span class="p">,</span>
<span class="linenos"> 4</span><span class="w"> </span><span class="p">}</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">foo</span><span class="p">(</span><span class="nx">n</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kc">undefined</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 7</span><span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="nx">x</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span>
<span class="linenos"> 8</span><span class="w"> </span><span class="p">}</span>
<span class="linenos"> 9</span>
<span class="linenos">10</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">bar</span><span class="p">(</span><span class="nx">n</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">11</span><span class="w">     </span><span class="kd">let</span><span class="w"> </span><span class="nx">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">x</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span>
<span class="linenos">12</span><span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">s</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">undefined</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s2">&quot;no&quot;</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">13</span><span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="nx">s</span><span class="o">!</span>
<span class="linenos">14</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">15</span>
<span class="linenos">16</span><span class="w"> </span><span class="nx">foo</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span><span class="w"> </span><span class="c1">// prints &quot;undefined&quot;</span>
<span class="linenos">17</span><span class="w"> </span><span class="nx">bar</span><span class="p">(</span><span class="mf">3</span><span class="p">)</span><span class="w"> </span><span class="c1">// prints &quot;no&quot;</span>
<span class="linenos">18</span>
<span class="linenos">19</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">x</span><span class="p">[</span><span class="mf">3</span><span class="p">]</span>
</pre></div>
</div>
<p>In the code above, the type of <em>y</em> is <em>string | undefined</em>, and the value of
<em>y</em> is <em>undefined</em>.</p>
<p>An indexing expression evaluated at runtime behaves as follows:</p>
<ul class="simple">
<li><p>First, the object reference expression is evaluated.</p></li>
<li><p>If the evaluation completes abruptly, then so does the indexing
expression, and the index expression is not evaluated.</p></li>
<li><p>If the evaluation completes normally, then the index expression is
evaluated.
The resultant value of the object reference expression refers to a record
instance.</p></li>
<li><p>If the record instance contains a key defined by the index expression,
then the result is the value mapped to the key.</p></li>
<li><p>Otherwise, the result is the literal <em>undefined</em>.</p></li>
</ul>
<div class="line-block" id="index-62">
<div class="line"><br /></div>
</div>
</section>
</section>
<section id="chaining-operator">
<span id="id35"></span><h2><span class="section-number">7.13. </span>Chaining Operator<a class="headerlink" href="#chaining-operator" title="Permalink to this heading">¶</a></h2>
<p>The <em>chaining operator</em> <code class="docutils literal notranslate"><span class="pre">?.</span></code> is used to effectively access values of
<em>nullish</em> types. It can be used in the following contexts:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#field-access-expressions"><span class="std std-ref">Field Access Expressions</span></a>,</p></li>
<li><p><a class="reference internal" href="#method-call-expression"><span class="std std-ref">Method Call Expression</span></a>,</p></li>
<li><p><a class="reference internal" href="#function-call-expression"><span class="std std-ref">Function Call Expression</span></a>,</p></li>
<li><p><a class="reference internal" href="#indexing-expression"><span class="std std-ref">Indexing Expression</span></a>.</p></li>
</ul>
<p>If the value of the expression to the left of <code class="docutils literal notranslate"><span class="pre">?.</span></code> is <em>undefined</em> or <em>null</em>,
then the evaluation of the entire surrounding expression is omitted. The
result of the entire expression is then <em>undefined</em>.</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="w"> </span><span class="kd">class</span><span class="w"> </span><span class="nx">Person</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 2</span><span class="w">     </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span>
<span class="linenos"> 3</span><span class="w">     </span><span class="nx">spouse?</span><span class="o">:</span><span class="w"> </span><span class="kt">Person</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">undefined</span>
<span class="linenos"> 4</span><span class="w">     </span><span class="kr">constructor</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 5</span><span class="w">         </span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">name</span>
<span class="linenos"> 6</span><span class="w">     </span><span class="p">}</span>
<span class="linenos"> 7</span><span class="w"> </span><span class="p">}</span>
<span class="linenos"> 8</span>
<span class="linenos"> 9</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">bob</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">Person</span><span class="p">(</span><span class="s2">&quot;Bob&quot;</span><span class="p">)</span>
<span class="linenos">10</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bob</span><span class="p">.</span><span class="nx">spouse</span><span class="o">?</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span><span class="w"> </span><span class="c1">// prints &quot;undefined&quot;</span>
<span class="linenos">11</span>
<span class="linenos">12</span><span class="w"> </span><span class="nx">bob</span><span class="p">.</span><span class="nx">spouse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">Person</span><span class="p">(</span><span class="s2">&quot;Alice&quot;</span><span class="p">)</span>
<span class="linenos">13</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">bob</span><span class="p">.</span><span class="nx">spouse</span><span class="o">?</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span><span class="w"> </span><span class="c1">// prints &quot;Alice&quot;</span>
</pre></div>
</div>
<p>A compile-time error occurs if an expression is not of a <em>nullish</em> type.</p>
<p>A compile-time error occurs if a chaining operator is placed in the context
where a variable is expected, e.g., in the left-hand-side expression of an
assignment (see <a class="reference internal" href="#assignment"><span class="std std-ref">Assignment</span></a>) or expression (see <a class="reference internal" href="#postfix-increment"><span class="std std-ref">Postfix Increment</span></a>,
<a class="reference internal" href="#postfix-decrement"><span class="std std-ref">Postfix Decrement</span></a>, <a class="reference internal" href="#prefix-increment"><span class="std std-ref">Prefix Increment</span></a> or <a class="reference internal" href="#prefix-decrement"><span class="std std-ref">Prefix Decrement</span></a>).</p>
<div class="line-block" id="index-63">
<div class="line"><br /></div>
</div>
</section>
<section id="new-expressions">
<span id="id36"></span><h2><span class="section-number">7.14. </span>New Expressions<a class="headerlink" href="#new-expressions" title="Permalink to this heading">¶</a></h2>
<p>The operation <strong>new</strong> instantiates an object of the <em>class</em> or <em>array</em> type.</p>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">newExpression</span>:
<span class="w">    </span><span class="nc">newClassInstance</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">newArrayInstance</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>A <em>class instance creation expression</em> creates new object that is an instance
of the specified class described in full detail below.</p>
<p>The creation of array instances is an experimental feature discussed in
<a class="reference internal" href="17_experimental.html#array-creation-expressions"><span class="std std-ref">Array Creation Expressions</span></a>.</p>
<div class="highlight-abnf notranslate" id="index-64"><div class="highlight"><pre><span></span><span class="nc">newClassInstance</span>:
<span class="w">    </span>&#39;<span class="nc">new</span>&#39;<span class="w"> </span><span class="nc">typeArguments</span>?<span class="w"> </span><span class="nc">typeReference</span><span class="w"> </span><span class="nc">arguments</span>?<span class="w"> </span><span class="nc">classBody</span>?
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>A <em>class instance creation expression</em> specifies a class to be instantiated.
It optionally lists all actual arguments for the constructor.</p>
<p>A <em>class instance creation expression</em> can throw an error as specified in
<a class="reference internal" href="12_errors.html#error-handling"><span class="std std-ref">Error Handling</span></a>.</p>
<p>A class instance creation expression is <em>standalone</em> if it has no assignment
or call context (see <a class="reference internal" href="6_conversions.html#assignment-like-contexts"><span class="std std-ref">Assignment-like Contexts</span></a>).</p>
<p>The execution of a class instance creation expression is performed as follows:</p>
<ul class="simple">
<li><p>A new instance of the class is created;</p></li>
<li><p>Initial values are given to all new instance fields with initializers, and
then to new instance fields with default values;</p></li>
<li><p>The constructor of the class is called to fully initialize the created
instance.</p></li>
</ul>
<p>The validity of the constructor call is similar to the validity of the method
call as discussed in <a class="reference internal" href="#step-3-semantic-correctness-check"><span class="std std-ref">Step 3: Semantic Correctness Check</span></a>, except the cases
discussed in the <a class="reference internal" href="9_classes.html#constructor-body"><span class="std std-ref">Constructor Body</span></a> section.</p>
<p>A compile-time error occurs if <em>typeReference</em> is a type parameter.</p>
<div class="line-block" id="index-65">
<div class="line"><br /></div>
</div>
</section>
<section id="cast-expressions">
<span id="id37"></span><h2><span class="section-number">7.15. </span>Cast Expressions<a class="headerlink" href="#cast-expressions" title="Permalink to this heading">¶</a></h2>
<p><em>Cast expressions</em> apply <em>cast operator</em>  ‘<code class="docutils literal notranslate"><span class="pre">as</span></code>’ to some <em>expression</em>
by issuing a value of the specified <em>type</em>.</p>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">castExpression</span>:
<span class="w">    </span><span class="nc">expression</span><span class="w"> </span>&#39;<span class="nc">as</span>&#39;<span class="w"> </span><span class="nc">type</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">class</span><span class="w"> </span><span class="nx">X</span><span class="w"> </span><span class="p">{}</span>
<span class="linenos">2</span>
<span class="linenos">3</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">x1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">X</span><span class="p">()</span>
<span class="linenos">4</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">ob</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">Object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">x1</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nb">Object</span>
<span class="linenos">5</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">x2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">ob</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="nx">X</span>
</pre></div>
</div>
<p>The cast operator converts the value <em>V</em> of one type (as denoted by the
expression) at runtime to a value of another type.</p>
<p>The cast expression introduces the target type for the casting context (see
<a class="reference internal" href="6_conversions.html#casting-contexts-and-conversions"><span class="std std-ref">Casting Contexts and Conversions</span></a>). The target type can be either <em>type</em>
or <em>typeReference</em>.</p>
<p id="index-66">A cast expression type is always the target type.</p>
<p>The result of a cast expression is a value, not a variable (even if the operand
expression is a variable).</p>
<p>The casting conversion (see <a class="reference internal" href="6_conversions.html#casting-contexts-and-conversions"><span class="std std-ref">Casting Contexts and Conversions</span></a>) converts
the operand value at runtime to the target type specified by the cast operator
(if needed).</p>
<p>A compile-time error occurs if the casting conversion cannot convert the
compile-time type of the operand to the target type specified by the cast
operator.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">as</span></code> cast cannot be performed during program execution, then
<em>ClassCastError</em> is thrown.</p>
<div class="line-block" id="index-67">
<div class="line"><br /></div>
</div>
</section>
<section id="instanceof-expression">
<span id="id38"></span><h2><span class="section-number">7.16. </span>InstanceOf Expression<a class="headerlink" href="#instanceof-expression" title="Permalink to this heading">¶</a></h2>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">instanceOfExpression</span>:
<span class="w">    </span><span class="nc">expression</span><span class="w"> </span>&#39;<span class="nc">instanceof</span>&#39;<span class="w"> </span><span class="nc">type</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>Any <em>instanceof</em> expression is of type <em>boolean</em>.</p>
<p>The <em>expression</em> operand of the operator <code class="docutils literal notranslate"><span class="pre">instanceof</span></code> must be of a
reference type. Otherwise, a compile-time error occurs.</p>
<p>A compile-time error occurs if <em>type</em> operand of the operator <code class="docutils literal notranslate"><span class="pre">instanceof</span></code> is
one of the following:</p>
<blockquote>
<div><ul class="simple">
<li><p>Type parameter (see <a class="reference internal" href="5_generics.html#generic-parameters"><span class="std std-ref">Generic Parameters</span></a>),</p></li>
<li><p>Union type that contains type parameter after normalization
(see <a class="reference internal" href="3_types.html#union-types-normalization"><span class="std std-ref">Union Types Normalization</span></a>),</p></li>
<li><p><em>Generic type</em> (see <a class="reference internal" href="5_generics.html#generics"><span class="std std-ref">Generics</span></a>)—this temporary limitation
is expected to be removed in the future.</p></li>
</ul>
</div></blockquote>
<p>If the type of <em>expression</em> at compile time is compatible with <em>type</em> (see
<a class="reference internal" href="15_semantics.html#type-compatibility"><span class="std std-ref">Type Compatibility</span></a>), then the result of the <em>instanceof</em> expression
is <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>Otherwise, an <em>instanceof</em> expression checks during program execution
whether the type of the value the expression successfully evaluates to is
compatible with <em>type</em> (see <a class="reference internal" href="15_semantics.html#type-compatibility"><span class="std std-ref">Type Compatibility</span></a>).
If so, then the result of the <em>instanceof</em> expression is <code class="docutils literal notranslate"><span class="pre">true</span></code>.
Otherwise, the result is <code class="docutils literal notranslate"><span class="pre">false</span></code>.
If the expression evaluation causes exception or error, then execution
control is transferred to a proper <code class="docutils literal notranslate"><span class="pre">catch</span></code> section or runtime system,
and the result of the <em>instanceof</em> expression cannot be determined.</p>
<div class="line-block" id="index-68">
<div class="line"><br /></div>
</div>
</section>
<section id="typeof-expression">
<span id="id39"></span><h2><span class="section-number">7.17. </span>TypeOf Expression<a class="headerlink" href="#typeof-expression" title="Permalink to this heading">¶</a></h2>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">typeOfExpression</span>:
<span class="w">    </span>&#39;<span class="nc">typeof</span>&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>Any <em>typeof</em> expression is of type <em>string</em>. The <em>typeof</em> expression values
of the types below are predefined, and the expressions require no evaluation:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type of Expression</strong></p></th>
<th class="head"><p><strong>Resulting String</strong></p></th>
<th class="head"><p><strong>Code Example</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>number/Number</p></td>
<td><p>“number”</p></td>
<td><div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">n</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span>
<span class="ow">typeof</span><span class="w"> </span><span class="nx">n</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">N</span><span class="o">:</span><span class="w"> </span><span class="kt">Number</span>
<span class="ow">typeof</span><span class="w"> </span><span class="nx">N</span>
</pre></div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>string/String</p></td>
<td><p>“string”</p></td>
<td><div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">s</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span>
<span class="ow">typeof</span><span class="w"> </span><span class="nx">s</span>
</pre></div>
</div>
</td>
</tr>
<tr class="row-even"><td><p>boolean/Boolean</p></td>
<td><p>“boolean”</p></td>
<td><div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">b</span><span class="o">:</span><span class="w"> </span><span class="kt">boolean</span>
<span class="ow">typeof</span><span class="w"> </span><span class="nx">b</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">B</span><span class="o">:</span><span class="w"> </span><span class="kt">Boolean</span>
<span class="ow">typeof</span><span class="w"> </span><span class="nx">B</span>
</pre></div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>any class or interface</p></td>
<td><p>“object”</p></td>
<td><div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">a</span><span class="o">:</span><span class="w"> </span><span class="kt">Object</span><span class="p">[]</span>
<span class="ow">typeof</span><span class="w"> </span><span class="nx">a</span>
</pre></div>
</div>
</td>
</tr>
<tr class="row-even"><td><p>any function type</p></td>
<td><p>“function”</p></td>
<td><div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">f</span><span class="o">:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{}</span>
<span class="ow">typeof</span><span class="w"> </span><span class="nx">f</span>
</pre></div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>undefined</p></td>
<td><p>“undefined”</p></td>
<td><div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="ow">typeof</span><span class="w"> </span><span class="kc">undefined</span>
</pre></div>
</div>
</td>
</tr>
<tr class="row-even"><td><p>null</p></td>
<td><p>“object”</p></td>
<td><div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="ow">typeof</span><span class="w"> </span><span class="kc">null</span>
</pre></div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>T | null, when T is a class
or interface or array</p></td>
<td><p>“object”</p></td>
<td><div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">x</span><span class="o">:</span><span class="w"> </span><span class="kt">Object</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="kc">null</span>
<span class="ow">typeof</span><span class="w"> </span><span class="nx">x</span>
</pre></div>
</div>
</td>
</tr>
<tr class="row-even"><td><p>enum</p></td>
<td><p>“number”</p></td>
<td><div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kd">enum</span><span class="w"> </span><span class="nx">C</span><span class="w"> </span><span class="p">{</span><span class="nx">R</span><span class="p">,</span><span class="w"> </span><span class="nx">G</span><span class="p">,</span><span class="w"> </span><span class="nx">B</span><span class="p">}</span>
<span class="kd">let</span><span class="w"> </span><span class="nx">c</span><span class="o">:</span><span class="w"> </span><span class="kt">C</span>
<span class="ow">typeof</span><span class="w"> </span><span class="nx">c</span>
</pre></div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>All high-performance numeric
value types and their boxed
versions:
<em>byte</em>, <em>short</em>, <em>int</em>, <em>long</em>,
<em>float</em>, <em>double</em>,
<em>Byte</em>, <em>Short</em>, <em>Int</em>, <em>long</em>,
<em>Long</em>, <em>Float</em>, and <em>Double</em></p></td>
<td><p>“byte”, “short”, “int”,
“long”, “float”, and
“double”</p></td>
<td><div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="nx">x</span><span class="o">:</span><span class="w"> </span><span class="kt">byte</span>
<span class="ow">typeof</span><span class="w"> </span><span class="nx">x</span>
<span class="p">...</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>The <em>typeof</em> expression value of all other types is to be evaluated during
program execution. The result of the evaluation is the <em>typeof</em> value.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>Type of
Expression</strong></p></th>
<th class="head"><p><strong>Code Example</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>union type</p></td>
<td><div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="w"> </span><span class="nx">f</span><span class="p">(</span><span class="nx">p</span><span class="o">:</span><span class="kt">A</span><span class="o">|</span><span class="nx">B</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="ow">typeof</span><span class="w"> </span><span class="nx">p</span>
<span class="p">}</span>
</pre></div>
</div>
</td>
</tr>
<tr class="row-odd"><td><p>type parameter</p></td>
<td><div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kd">class</span><span class="w"> </span><span class="nx">A</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">|</span><span class="kc">null</span><span class="o">|</span><span class="kc">undefined</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="nx">f</span><span class="o">:</span><span class="w"> </span><span class="kt">T</span>
<span class="w">   </span><span class="nx">m</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="ow">typeof</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">f</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="kr">constructor</span><span class="p">(</span><span class="nx">p</span><span class="o">:</span><span class="kt">T</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">p</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<p>If the expression evaluation causes exception or error, then the control of
the execution is transferred to a proper <code class="docutils literal notranslate"><span class="pre">catch</span></code> section of the runtime
system. The result of the <em>typeof</em> expression cannot be determined in that case.</p>
<div class="line-block" id="index-69">
<div class="line"><br /></div>
</div>
</section>
<section id="ensure-not-nullish-expression">
<span id="ensure-not-nullish-expressions"></span><h2><span class="section-number">7.18. </span>Ensure-Not-Nullish Expression<a class="headerlink" href="#ensure-not-nullish-expression" title="Permalink to this heading">¶</a></h2>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">ensureNotNullishExpression</span>:
<span class="w">    </span><span class="nc">expression</span><span class="w"> </span>&#39;!&#39;
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>An <em>ensure-not-nullish expression</em> is a postfix expression with the operator
‘<code class="docutils literal notranslate"><span class="pre">!</span></code>’. An <em>ensure-not-nullish expression</em> in the expression <em>e!</em> checks
whether <em>e</em> of <em>nullish</em> type (see <a class="reference internal" href="3_types.html#nullish-types"><span class="std std-ref">Nullish Types</span></a>) evaluates to the
<em>nullish</em> value.</p>
<p>If the result of the evaluation of <em>e</em> is not equal to <em>null</em> or <em>undefined</em>,
then the result of <em>e!</em> is the outcome of the evaluation of <em>e</em>.</p>
<p>If the result of the evaluation of <em>e</em> is equal to <em>null</em> or <em>undefined</em>,
then <em>NullPointerError</em> is thrown.</p>
<p>A compile-time error occurs if <em>e</em> is not a <em>nullish</em> type.</p>
<p>The type of <em>ensure-not-nullish</em> expression is the non-nullish variant of the
type of <em>e</em>.</p>
<div class="line-block" id="index-70">
<div class="line"><br /></div>
</div>
</section>
<section id="nullish-coalescing-expression">
<span id="id40"></span><h2><span class="section-number">7.19. </span>Nullish-Coalescing Expression<a class="headerlink" href="#nullish-coalescing-expression" title="Permalink to this heading">¶</a></h2>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">nullishCoalescingExpression</span>:
<span class="w">    </span><span class="nc">expression</span><span class="w"> </span>&#39;??&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>A <em>nullish-coalescing expression</em> is a binary expression that uses the operator
‘<code class="docutils literal notranslate"><span class="pre">??</span></code>’, and checks whether the evaluation of the left-hand-side expression
equals the <em>nullish</em> value:</p>
<ul class="simple">
<li><p>If so, then the right-hand-side expression evaluation is the result
of a nullish-coalescing expression.</p></li>
<li><p>If not so, then the left-hand-side expression evaluation result is
the result of a nullish-coalescing expression, and the right-hand-side
expression is not evaluated (the operator ‘<code class="docutils literal notranslate"><span class="pre">??</span></code>’ is thus <strong>lazy</strong>).</p></li>
</ul>
<p id="index-71">A compile-time error occurs if the left-hand-side expression is not a
reference type.</p>
<p>The type of a nullish-coalescing expression is <em>union type</em> (see
<a class="reference internal" href="3_types.html#union-types"><span class="std std-ref">Union Types</span></a>) of the non-nullish variant of the types used in the
left-hand-side and right-hand-side expressions.</p>
<p>The semantics of a nullish-coalescing expression is represented in the
following example:</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">expression1</span><span class="w"> </span><span class="o">??</span><span class="w"> </span><span class="nx">expression2</span>
<span class="linenos">2</span>
<span class="linenos">3</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">expression1</span>
<span class="linenos">4</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">expression2</span>
<span class="linenos">5</span>
<span class="linenos">6</span><span class="w"> </span><span class="c1">// Type of x is Type(expression1)|Type(expression2)</span>
</pre></div>
</div>
<p>A compile-time error occurs if the nullish-coalescing operator is mixed
with conditional-and or conditional-or operators without parentheses.</p>
<div class="line-block" id="index-72">
<div class="line"><br /></div>
</div>
</section>
<section id="unary-expressions">
<span id="id41"></span><h2><span class="section-number">7.20. </span>Unary Expressions<a class="headerlink" href="#unary-expressions" title="Permalink to this heading">¶</a></h2>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">unaryExpression</span>:
<span class="w">    </span><span class="nc">expression</span><span class="w"> </span>&#39;++&#39;
<span class="w">    </span>|<span class="w"> </span><span class="nc">expression</span><span class="w"> </span>&#39;––&#39;
<span class="w">    </span>|<span class="w"> </span>&#39;++&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span>|<span class="w"> </span>&#39;––&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span>|<span class="w"> </span>&#39;+&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span>|<span class="w"> </span>&#39;–&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span>|<span class="w"> </span>&#39;~&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span>|<span class="w"> </span>&#39;!&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>All expressions with unary operators (except postfix increment and postfix
decrement operators) group right-to-left for ‘~+x’ to have the same meaning
as ‘~(+x)’.</p>
<div class="line-block" id="index-73">
<div class="line"><br /></div>
</div>
<section id="postfix-increment">
<span id="id42"></span><h3><span class="section-number">7.20.1. </span>Postfix Increment<a class="headerlink" href="#postfix-increment" title="Permalink to this heading">¶</a></h3>
<p>A <em>postfix increment expression</em> is an expression followed by the increment
operator ‘<span class="math notranslate nohighlight">\(++\)</span>’.</p>
<p>A compile-time error occurs if the type of the variable resultant from the
<em>expression</em> is not convertible (see <a class="reference internal" href="6_conversions.html#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a>) to a numeric
type.</p>
<p>The type of a postfix increment expression is the type of the variable. The
result of a postfix increment expression is a value, not a variable.</p>
<p>If the evaluation of the operand expression completes normally at runtime, then:</p>
<ul class="simple">
<li><p>The value <em>1</em> is added to the value of the variable by using necessary
conversions (see <a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a>); and</p></li>
<li><p>The sum is stored back into the variable.</p></li>
</ul>
<p id="index-74">Otherwise, the postfix increment expression completes abruptly, and no
incrementation occurs.</p>
<p>The  value of the postfix increment expression is the value of the variable
<em>before</em> the new value is stored.</p>
<div class="line-block" id="index-75">
<div class="line"><br /></div>
</div>
</section>
<section id="postfix-decrement">
<span id="id43"></span><h3><span class="section-number">7.20.2. </span>Postfix Decrement<a class="headerlink" href="#postfix-decrement" title="Permalink to this heading">¶</a></h3>
<p>A <em>postfix decrement expression</em> is an expression followed by the decrement
operator ‘<span class="math notranslate nohighlight">\(--\)</span>‘.</p>
<p>A compile-time error occurs if the type of the variable resultant from the
<em>expression</em> is not convertible (see <a class="reference internal" href="6_conversions.html#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a>) to a numeric
type.</p>
<p>The type of a postfix decrement expression is the type of the variable. The
result of a postfix decrement expression is a value, not a variable.</p>
<p>If evaluation of the operand expression completes at runtime, then:</p>
<ul class="simple" id="index-76">
<li><p>The value <em>1</em> is subtracted from the value of the variable by using
necessary conversions (see <a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a>); and</p></li>
<li><p>The sum is stored back into the variable.</p></li>
</ul>
<p>Otherwise, the postfix decrement expression completes abruptly, and
no decrementation occurs.</p>
<p>The value of the postfix decrement expression is the value of the variable
<em>before</em> the new value is stored.</p>
<div class="line-block" id="index-77">
<div class="line"><br /></div>
</div>
</section>
<section id="prefix-increment">
<span id="id44"></span><h3><span class="section-number">7.20.3. </span>Prefix Increment<a class="headerlink" href="#prefix-increment" title="Permalink to this heading">¶</a></h3>
<p>A <em>prefix increment expression</em> is an expression preceded by the operator
‘<span class="math notranslate nohighlight">\(++\)</span>’.</p>
<p>A compile-time error occurs if the type of the variable resultant from the
<em>expression</em> is not convertible (see <a class="reference internal" href="6_conversions.html#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a>) to a numeric
type.</p>
<p>The type of a prefix increment expression is the type of the variable. The
result of a prefix increment expression is a value, not a variable.</p>
<p>If evaluation of the operand expression completes normally at runtime, then:</p>
<ul class="simple" id="index-78">
<li><p>The value <em>1</em> is added to the value of the variable by using necessary
conversions (see <a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a>); and</p></li>
<li><p>The sum is stored back into the variable.</p></li>
</ul>
<p>Otherwise, the prefix increment expression completes abruptly, and no
incrementation occurs.</p>
<p>The  value of the  prefix increment expression is the value of the variable
<em>before</em> the new value is stored.</p>
<div class="line-block" id="index-79">
<div class="line"><br /></div>
</div>
</section>
<section id="prefix-decrement">
<span id="id45"></span><h3><span class="section-number">7.20.4. </span>Prefix Decrement<a class="headerlink" href="#prefix-decrement" title="Permalink to this heading">¶</a></h3>
<p>A <em>prefix decrement expression</em> is an expression preceded by the operator
‘<span class="math notranslate nohighlight">\(--\)</span>‘.</p>
<p>A compile-time error occurs if the type of the variable resultant from the
<em>expression</em> is not convertible (see <a class="reference internal" href="6_conversions.html#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a>) to a numeric
type.</p>
<p>The type of a prefix decrement expression is the type of the variable. The
result of a prefix decrement expression is a value, not a variable.</p>
<p id="index-80">If evaluation of the operand expression completes normally at runtime, then:</p>
<ul class="simple">
<li><p>The value <em>1</em> is subtracted from the value of the variable by using
necessary conversions (see <a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a>); and</p></li>
<li><p>The sum is stored back into the variable.</p></li>
</ul>
<p>Otherwise, the prefix decrement expression completes abruptly, and no
decrementation occurs.</p>
<p>The value of the prefix decrement expression is the value of the variable
<em>before</em> the new value is stored.</p>
<div class="line-block" id="index-81">
<div class="line"><br /></div>
</div>
</section>
<section id="unary-plus">
<span id="id46"></span><h3><span class="section-number">7.20.5. </span>Unary Plus<a class="headerlink" href="#unary-plus" title="Permalink to this heading">¶</a></h3>
<p>A <em>unary plus expression</em> is an expression preceded by the operator ‘<span class="math notranslate nohighlight">\(+\)</span>’.</p>
<p>The type of the operand <em>expression</em> with the unary operator ‘<span class="math notranslate nohighlight">\(+\)</span>’ must
be convertible  (see <a class="reference internal" href="6_conversions.html#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a>) to a numeric type. Otherwise,
a compile-time error occurs.</p>
<p>The numeric types conversion (see <a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a>) is
performed on the operand to ensure that the resultant type is that of the
unary plus expression. The result of a unary plus expression is always a value,
not a variable (even if the result of the operand expression is a variable).</p>
<div class="line-block" id="index-82">
<div class="line"><br /></div>
</div>
</section>
<section id="unary-minus">
<span id="id47"></span><h3><span class="section-number">7.20.6. </span>Unary Minus<a class="headerlink" href="#unary-minus" title="Permalink to this heading">¶</a></h3>
<p>A <em>unary minus expression</em> is an expression preceded by the operator
‘<span class="math notranslate nohighlight">\(-\)</span>‘.</p>
<p>The type of the operand <em>expression</em> with the unary operator ‘<span class="math notranslate nohighlight">\(-\)</span>’ must
be convertible (see <a class="reference internal" href="6_conversions.html#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a>) to a numeric type. Otherwise,
a compile-time error occurs.</p>
<p>The numeric types conversion (see <a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a>)
is performed on the operand to ensure that the resultant type is that of the
unary minus expression.
The result of a unary minus expression is a value, not a variable (even if the
result of the operand expression is a variable).</p>
<p>A unary numeric promotion performs the value set conversion (see
<a class="reference internal" href="6_conversions.html#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a>).</p>
<p>The unary negation operation is always performed on, and its result is drawn
from the same value set as the promoted operand value.</p>
<p id="index-83">Further value set conversions are then performed on that same result.</p>
<p>The value of a unary minus expression at runtime is the arithmetic negation
of the promoted value of the operand.</p>
<p>The negation of integer values is the same as subtraction from zero. The ArkTS
programming language uses two’s-complement representation for integers. The
range of two’s-complement value is not symmetric. The same maximum negative
number results from the negation of the maximum negative <em>int</em> or <em>long</em>.
In that case, an overflow occurs but throws no exception or error.
For any integer value <em>x</em>, <em>-x</em> is equal to <em>(~x)+1</em>.</p>
<p>The negation of floating-point values is <em>not</em> the same as subtraction from
zero (if <em>x</em> is <em>+0.0</em>, then <em>0.0-x</em> is <em>+0.0</em>, however <em>-x</em> is <em>-0.0</em>).</p>
<p>A unary minus merely inverts the sign of a floating-point number. Special
cases to consider are as follows:</p>
<ul class="simple">
<li><p>The operand NaN results in NaN (NaN has no sign).</p></li>
<li><p>The operand infinity results in the infinity of the opposite sign.</p></li>
<li><p>The operand zero results in zero of the opposite sign.</p></li>
</ul>
<div class="line-block" id="index-84">
<div class="line"><br /></div>
</div>
</section>
<section id="bitwise-complement">
<span id="id48"></span><h3><span class="section-number">7.20.7. </span>Bitwise Complement<a class="headerlink" href="#bitwise-complement" title="Permalink to this heading">¶</a></h3>
<p>A <em>bitwise complement expression</em> is an expression preceded by the operator ‘<code class="docutils literal notranslate"><span class="pre">~</span></code>’.</p>
<p>The type of the operand <em>expression</em> with the unary operator ‘~’ must be
convertible (see <a class="reference internal" href="6_conversions.html#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a>) to a primitive integer type.
Otherwise, a compile-time error occurs.</p>
<p>The numeric types conversion (see <a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a>)
is performed on the operand to ensure that the resultant type is that of the
unary bitwise complement expression.</p>
<p>The result of a unary bitwise complement expression is a value, not a variable
(even if the result of the operand expression is a variable).</p>
<p>The value of a unary bitwise complement expression at runtime is the bitwise
complement of the promoted value of the operand. In all cases, <em>~x</em> equals
<em>(-x)-1</em>.</p>
<div class="line-block" id="index-85">
<div class="line"><br /></div>
</div>
</section>
<section id="logical-complement">
<span id="id49"></span><h3><span class="section-number">7.20.8. </span>Logical Complement<a class="headerlink" href="#logical-complement" title="Permalink to this heading">¶</a></h3>
<p>A <em>logical complement expression</em> is an expression preceded by the operator
‘<span class="math notranslate nohighlight">\(!\)</span>’.</p>
<p>The type of the operand <em>expression</em> with the unary ‘<code class="docutils literal notranslate"><span class="pre">!</span></code>’ operator must be
<em>boolean</em> or <em>Boolean</em>. Otherwise, a compile-time error occurs.</p>
<p>The unary logical complement expression’s type is <em>boolean</em>.</p>
<p>The unboxing conversion (see <a class="reference internal" href="6_conversions.html#unboxing-conversions"><span class="std std-ref">Unboxing Conversions</span></a>) is
performed on the operand at runtime if needed.</p>
<p>The value of a unary logical complement expression is <em>true</em> if the
(possibly converted) operand value is <code class="docutils literal notranslate"><span class="pre">false</span></code>, and <em>false</em> if the operand
value (possibly converted) is <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<div class="line-block" id="index-86">
<div class="line"><br /></div>
</div>
</section>
</section>
<section id="multiplicative-expressions">
<span id="id50"></span><h2><span class="section-number">7.21. </span>Multiplicative Expressions<a class="headerlink" href="#multiplicative-expressions" title="Permalink to this heading">¶</a></h2>
<p>Multiplicative expressions use <em>multiplicative operators</em> ‘*’, ‘/’, and ‘%’:</p>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">multiplicativeExpression</span>:
<span class="w">    </span><span class="nc">expression</span><span class="w"> </span>&#39;<span class="o">*</span>&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">expression</span><span class="w"> </span>&#39;<span class="o">/</span>&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">expression</span><span class="w"> </span>&#39;%&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>The multiplicative operators group left-to-right.</p>
<p>The type of each operand in a multiplicative operator must be convertible (see
<a class="reference internal" href="6_conversions.html#contexts-and-conversions"><span class="std std-ref">Contexts and Conversions</span></a>) to a numeric type. Otherwise, a compile-time
error occurs.</p>
<p>The numeric types conversion (see <a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a>)
is performed on both operands to ensure that the resultant type is the type of
the multiplicative expression.</p>
<p>The result of a unary bitwise complement expression is a value, not a
variable (even if the operand expression is a variable).</p>
<div class="line-block" id="index-87">
<div class="line"><br /></div>
</div>
<section id="multiplication">
<span id="id51"></span><h3><span class="section-number">7.21.1. </span>Multiplication<a class="headerlink" href="#multiplication" title="Permalink to this heading">¶</a></h3>
<p>The binary operator ‘*’ performs multiplication, and returns the product of
its operands.</p>
<p>Multiplication is a commutative operation if operand expressions have no
side effects.</p>
<p>Integer multiplication is associative when all operands are of the same type.</p>
<p>Floating-point multiplication is not associative.</p>
<p>If overflow occurs during integer multiplication, then:</p>
<ul class="simple">
<li><p>The result is the low-order bits of the mathematical product as represented
in some sufficiently large two’s-complement format.</p></li>
<li><p>The sign of the result can be other than the sign of the mathematical
product of the two operand values.</p></li>
</ul>
<p>A floating-point multiplication result is determined in compliance with the
IEEE 754 arithmetic:</p>
<ul id="index-88">
<li><p>The result is NaN if:</p>
<ul class="simple">
<li><p>Either operand is NaN;</p></li>
<li><p>Infinity is multiplied by zero.</p></li>
</ul>
</li>
<li><p>If the result is not NaN, then the sign of the result is as follows:</p>
<ul class="simple">
<li><p>Positive if both operands have the same sign; and</p></li>
<li><p>Negative if the operands have different signs.</p></li>
</ul>
</li>
<li><p>If infinity is multiplied by a finite value, then the multiplication results
in a signed infinity (the sign is determined by the rule above).</p></li>
<li><p>If neither NaN nor infinity is involved, then the exact mathematical product
is computed.</p>
<p>The product is rounded to the nearest value in the chosen value set by
using the IEEE 754 ‘<em>round-to-nearest</em>’ mode. The ArkTS programming
language requires gradual underflow support as defined by IEEE 754
(see <a class="reference internal" href="3_types.html#floating-point-types-and-operations"><span class="std std-ref">Floating-Point Types and Operations</span></a>).</p>
<p>If the magnitude of the product is too large to represent, then the
operation overflows, and the result is an appropriately signed infinity.</p>
</li>
</ul>
<p>The evaluation of a multiplication operator ‘*’ never throws an error despite
possible overflow, underflow, or loss of information.</p>
<div class="line-block" id="index-89">
<div class="line"><br /></div>
</div>
</section>
<section id="division">
<span id="id52"></span><h3><span class="section-number">7.21.2. </span>Division<a class="headerlink" href="#division" title="Permalink to this heading">¶</a></h3>
<p>The binary operator ‘/’ performs division and returns the quotient of its
left-hand and right-hand operands (<em>dividend</em> and <em>divisor</em> respectively).</p>
<p>Integer division rounds toward <em>0</em>, i.e., the quotient of integer operands
<em>n</em> and <em>d</em>, after a numeric types conversion on both (see
<a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a> for details), is
an integer value <em>q</em> with the largest possible magnitude that
satisfies <span class="math notranslate nohighlight">\(|d\cdot{}q|\leq{}|n|\)</span>.</p>
<p>Note that <em>q</em> is:</p>
<ul class="simple">
<li><p>Positive when |n| <span class="math notranslate nohighlight">\(\geq{}\)</span> |d|, while <em>n</em> and <em>d</em> have the same sign;
but</p></li>
<li><p>Negative when |n| <span class="math notranslate nohighlight">\(\geq{}\)</span> |d|, while <em>n</em> and <em>d</em> have opposite signs.</p></li>
</ul>
<p id="index-90">Only a single special case does not comply with this rule: the integer overflow
occurs, and the result equals the dividend if the dividend is a negative
integer of the largest possible magnitude for its type, while the divisor
is <em>-1</em>.</p>
<p>This case throws no exception or error despite the overflow. However, if in
an integer division the divisor value is <em>0</em>, then <em>ArithmeticError</em> is
thrown.</p>
<p>A floating-point division result is determined in compliance with the IEEE 754
arithmetic:</p>
<ul class="simple">
<li><p>The result is NaN if:</p>
<ul>
<li><p>Either operand is NaN;</p></li>
<li><p>Both operands are infinity; or</p></li>
<li><p>Both operands are zero.</p></li>
</ul>
</li>
</ul>
<ul class="simple" id="index-91">
<li><p>If the result is not NaN, then the sign of the result is:</p>
<ul>
<li><p>Positive if both operands have the same sign; or</p></li>
<li><p>Negative if the operands have different signs.</p></li>
</ul>
</li>
<li><p>The division results in a signed infinity (the sign is determined by
the rule above) if:</p>
<ul>
<li><p>Infinity is divided by a finite value; and</p></li>
<li><p>A nonzero finite value is divided by zero.</p></li>
</ul>
</li>
<li><p>The division results in a signed zero (the sign is determined by the
rule above) if:</p>
<ul>
<li><p>A finite value is divided by infinity; and</p></li>
<li><p>Zero is divided by any other finite value.</p></li>
</ul>
</li>
</ul>
<ul id="index-92">
<li><p>If neither NaN nor infinity is involved, then the exact mathematical
quotient is computed.</p>
<p>If the magnitude of the product is too large to represent, then the
operation overflows, and the result is an appropriately signed infinity.</p>
</li>
</ul>
<p>The quotient is rounded to the nearest value in the chosen value set by
using the IEEE 754 ‘<em>round-to-nearest</em>’ mode. The ArkTS programming
language requires gradual underflow support as defined by IEEE 754 (see
<a class="reference internal" href="3_types.html#floating-point-types-and-operations"><span class="std std-ref">Floating-Point Types and Operations</span></a>).</p>
<p>The evaluation of a floating-point division operator ‘/’ never throws an error
despite possible overflow, underflow, division by zero, or loss of information.</p>
<div class="line-block" id="index-93">
<div class="line"><br /></div>
</div>
</section>
<section id="remainder">
<span id="id53"></span><h3><span class="section-number">7.21.3. </span>Remainder<a class="headerlink" href="#remainder" title="Permalink to this heading">¶</a></h3>
<p>The binary operator ‘%’ yields the remainder of its operands (<em>dividend</em> as
left-hand, and <em>divisor</em> as the right-hand operand) from an implied division.</p>
<p>The remainder operator in ArkTS accepts floating-point operands (unlike in
C and C++).</p>
<p>The remainder operation on integer operands (for the numeric type conversion
on both see <a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a>) produces a result
value, i.e., <span class="math notranslate nohighlight">\((a/b)*b+(a\%b)\)</span> equals <em>a</em>.</p>
<p id="index-94">This equality holds even in the special case where the dividend is a negative
integer of the largest possible magnitude of its type, and the divisor is <em>-1</em>
(the remainder is then <em>0</em>).</p>
<p>According to this rule, the result of the remainder operation can only be:</p>
<ul class="simple">
<li><p>Negative if the dividend is negative; or</p></li>
<li><p>Positive if the dividend is positive.</p></li>
</ul>
<p>The magnitude of the result is always less than that of the divisor.</p>
<p>If the value of the divisor for an integer remainder operator is <em>0</em>, then
<em>ArithmeticError</em> is thrown.</p>
<p>A floating-point remainder operation result as computed by the operator ‘%’ is
different than that produced by the remainder operation defined by IEEE 754.
The IEEE 754 remainder operation computes the remainder from a rounding
division (not a truncating division), and its behavior is different from that
of the usual integer remainder operator. Contrarily, ArkTS presumes that on
floating-point operations the operator ‘%’ behaves in the same manner as the
integer remainder operator (comparable to the C library function <em>fmod</em>). The
standard library (see <a class="reference internal" href="18_stdlib.html#standard-library"><span class="std std-ref">Standard Library</span></a>) routine <em>Math.IEEEremainder</em>
can compute the IEEE 754 remainder operation.</p>
<p id="index-95">The result of a floating-point remainder operation is determined in compliance
with the IEEE 754 arithmetic:</p>
<ul class="simple">
<li><p>The result is NaN if:</p>
<ul>
<li><p>Either operand is NaN;</p></li>
<li><p>The dividend is infinity;</p></li>
<li><p>The divisor is zero; or</p></li>
<li><p>The dividend is infinity, and the divisor is zero.</p></li>
</ul>
</li>
<li><p>If the result is not NaN, then the sign of the result is the same as the
sign of the dividend.</p></li>
<li><p>The result equals the dividend if:</p>
<ul>
<li><p>The dividend is finite, and the divisor is infinity; or</p></li>
<li><p>If the dividend is zero, and the divisor is finite.</p></li>
</ul>
</li>
</ul>
<ul class="simple" id="index-96">
<li><p>If infinity, zero, or NaN are not involved, then the floating-point remainder
<em>r</em> from the division of the dividend <em>n</em> by the divisor <em>d</em> is determined
by the mathematical relation <span class="math notranslate nohighlight">\(r=n-(d\cdot{}q)\)</span>, in which <em>q</em> is an
integer that is only:</p>
<ul>
<li><p>Negative if <span class="math notranslate nohighlight">\(n/d\)</span> is negative, or</p></li>
<li><p>Positive if <span class="math notranslate nohighlight">\(n/d\)</span> is positive.</p></li>
</ul>
</li>
<li><p>The magnitude of <em>q</em> is the largest possible without exceeding the
magnitude of the true mathematical quotient of <em>n</em> and <em>d</em>.</p></li>
</ul>
<p>The evaluation of the floating-point remainder operator ‘%’ never throws
an error, even if the right-hand operand is zero. Overflow, underflow, or
loss of precision cannot occur.</p>
<div class="line-block" id="index-97">
<div class="line"><br /></div>
</div>
</section>
</section>
<section id="additive-expressions">
<span id="id54"></span><h2><span class="section-number">7.22. </span>Additive Expressions<a class="headerlink" href="#additive-expressions" title="Permalink to this heading">¶</a></h2>
<p>Additive expressions use <em>additive operators</em> ‘+’ and ‘-‘:</p>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">additiveExpression</span>:
<span class="w">    </span><span class="nc">expression</span><span class="w"> </span>&#39;+&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">expression</span><span class="w"> </span>&#39;-&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>The additive operators group left-to-right.</p>
<p>If either operand of the operator is ‘+’ of type <em>string</em>, then the operation
is a string concatenation (see <a class="reference internal" href="#string-concatenation"><span class="std std-ref">String Concatenation</span></a>). In all other
cases, the type of each operand of the operator ‘+’ must be convertible
(see <a class="reference internal" href="6_conversions.html#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a>) to a numeric type. Otherwise, a compile-time
error occurs.</p>
<p>The type of each operand of the binary operator ‘-’ in all cases must be
convertible (see <a class="reference internal" href="6_conversions.html#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a>) to a numeric type. Otherwise,
a compile-time error occurs.</p>
<div class="line-block" id="index-98">
<div class="line"><br /></div>
</div>
<section id="string-concatenation">
<span id="id55"></span><h3><span class="section-number">7.22.1. </span>String Concatenation<a class="headerlink" href="#string-concatenation" title="Permalink to this heading">¶</a></h3>
<p>If one operand of an expression is of type <em>string</em>, then the string
conversion (see <a class="reference internal" href="6_conversions.html#string-operator-contexts"><span class="std std-ref">String Operator Contexts</span></a>) is performed on the other operand
at runtime to produce a string.</p>
<p>String concatenation produces a reference to a <em>string</em> object that is a
concatenation of two operand strings. The left-hand operand characters precede
the right-hand operand characters in a newly created string.</p>
<p>If the expression is not a constant expression (see <a class="reference internal" href="#constant-expressions"><span class="std std-ref">Constant Expressions</span></a>),
then a new <em>string</em> object is created (see <a class="reference internal" href="#new-expressions"><span class="std std-ref">New Expressions</span></a>).</p>
<div class="line-block" id="index-99">
<div class="line"><br /></div>
</div>
</section>
<section id="additive-operators-and-for-numeric-types">
<span id="additive-operators-for-numeric-types"></span><h3><span class="section-number">7.22.2. </span>Additive Operators ‘+’ and ‘-’ for Numeric Types<a class="headerlink" href="#additive-operators-and-for-numeric-types" title="Permalink to this heading">¶</a></h3>
<p>The binary operator ‘+’ applied to two numeric type operands performs addition
and produces the sum of such operands.</p>
<p>The binary operator ‘-’ performs subtraction and produces the difference of
two numeric operands.</p>
<p>The numeric types conversion (see <a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a>)
is performed on the operands.</p>
<p>The type of an additive expression on numeric operands is the promoted type of
that expression’s operands.
If the promoted type is <em>int</em> or <em>long</em>, then integer arithmetic is performed.
If the promoted type is <em>float</em> or <em>double</em>, then floating-point arithmetic is
performed.</p>
<p id="index-100">If operand expressions have no side effects, then addition is a commutative
operation.</p>
<p>If all operands are of the same type, then integer addition is associative.</p>
<p>Floating-point addition is not associative.</p>
<p>If overflow occurs on an integer addition, then:</p>
<ul class="simple">
<li><p>The result is the low-order bits of the mathematical sum as represented in
a sufficiently large two’s-complement format.</p></li>
<li><p>The sign of the result is different than that of the mathematical sum of
the operands’ values.</p></li>
</ul>
<p>The result of a floating-point addition is determined in compliance with the
IEEE 754 arithmetic:</p>
<ul class="simple" id="index-101">
<li><p>The result is NaN if:</p>
<ul>
<li><p>Either operand is NaN; or</p></li>
<li><p>The operands are two infinities of opposite sign.</p></li>
</ul>
</li>
<li><p>The sum of two infinities of the same sign is the infinity of that sign.</p></li>
<li><p>The sum of infinity and a finite value equals the infinite operand.</p></li>
<li><p>The sum of two zeros of opposite sign is positive zero.</p></li>
<li><p>The sum of two zeros of the same sign is zero of that sign.</p></li>
<li><p>The sum of zero and a nonzero finite value is equal to the nonzero operand.</p></li>
<li><p>The sum of two nonzero finite values of the same magnitude and opposite sign
is positive zero.</p></li>
<li><p>If infinity, zero, or NaN are not involved, and the operands have the same
sign or different magnitudes, then the exact sum is computed mathematically.</p></li>
</ul>
<p>If the magnitude of the sum is too large to represent, then the operation
overflows, and the result is an appropriately signed infinity.</p>
<p id="index-102">Otherwise, the sum is rounded to the nearest value within the chosen value set
by using the IEEE 754 ‘<em>round-to-nearest mode</em>’. The ArkTS programming language
requires gradual underflow support as defined by IEEE 754 (see
<a class="reference internal" href="3_types.html#floating-point-types-and-operations"><span class="std std-ref">Floating-Point Types and Operations</span></a>).</p>
<p>When applied to two numeric type operands, the binary operator ‘-’ performs
subtraction, and returns the difference of such operands (<em>minuend</em> as left-hand,
and <em>subtrahend</em> as the right-hand operand).</p>
<p>The result of <em>a-b</em> is always the same as that of <em>a+(-b)</em> in both integer and
floating-point subtraction.</p>
<p>The subtraction from zero for integer values is the same as negation. However,
the subtraction from zero for floating-point operands and negation is <em>not</em>
the same (if <em>x</em> is <em>+0.0</em>, then <em>0.0-x</em> is <em>+0.0</em>; however <em>-x</em> is <em>-0.0</em>).</p>
<p>The evaluation of a numeric additive operator never throws an error despite
possible overflow, underflow, or loss of information.</p>
<div class="line-block" id="index-103">
<div class="line"><br /></div>
</div>
</section>
</section>
<section id="shift-expressions">
<span id="id56"></span><h2><span class="section-number">7.23. </span>Shift Expressions<a class="headerlink" href="#shift-expressions" title="Permalink to this heading">¶</a></h2>
<p>Shift expressions use <em>shift operators</em> ‘&lt;&lt;’ (left shift), ‘&gt;&gt;’ (signed right
shift), and ‘&gt;&gt;&gt;’ (unsigned right shift). The value to be shifted is the
left-hand operand in a shift operator, and the right-hand operand specifies the
shift distance:</p>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">shiftExpression</span>:
<span class="w">    </span><span class="nc">expression</span><span class="w"> </span>&#39;&lt;&lt;&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">expression</span><span class="w"> </span>&#39;&gt;&gt;&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">expression</span><span class="w"> </span>&#39;&gt;&gt;&gt;&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>The shift operators group left-to-right.</p>
<p>Numeric types conversion (see <a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a>) is performed
separately on each operand to ensure that both operands are of primitive
integer type.</p>
<p><strong>Note</strong>: If the initial type of one or both operands is <code class="docutils literal notranslate"><span class="pre">double</span></code> or
<code class="docutils literal notranslate"><span class="pre">float</span></code>, then such operand or operands are  first truncated to appropriate
integer type. If both operands are of type <em>bigint</em>, then shift operator
is applied to bigint operands.</p>
<p>A compile-time error occurs if either operand in a shift operator (after unary
numeric promotion) is not a primitive integer type or bigint.</p>
<p id="index-104">The shift expression type is the promoted type of the left-hand operand.</p>
<p>If the left-hand operand is of the promoted type <em>int</em>, then only five
lowest-order bits of the right-hand operand specify the shift distance
(as if using a bitwise logical AND operator ‘&amp;’ with the mask value <em>0x1f</em>
or <em>0b11111</em> on the right-hand operand), and thus it is always within
the inclusive range of <em>0</em> through <em>31</em>.</p>
<p>If the left-hand operand is of the promoted type <em>long</em>, then only six
lowest-order bits of the right-hand operand specify the shift distance
(as if using a bitwise logical AND operator ‘&amp;’ with the mask value <em>0x3f</em>
or <em>0b111111</em> the right-hand operand). Thus, it is always within the
inclusive range of <em>0</em> through <em>63</em>.</p>
<p>Shift operations are performed on the two’s-complement integer
representation of the value of the left-hand operand at runtime.</p>
<p>The value of <em>n</em> &lt;&lt; <em>s</em> is <em>n</em> left-shifted by <em>s</em> bit positions. It is
equivalent to multiplication by two to the power <em>s</em> even in case of an
overflow.</p>
<p id="index-105">The value of <em>n</em> &gt;&gt; <em>s</em> is <em>n</em> right-shifted by <em>s</em> bit positions with
sign-extension. The resultant value is <span class="math notranslate nohighlight">\(floor(n / 2s)\)</span>. If <em>n</em> is
non-negative, then it is equivalent to truncating integer division (as computed
by the integer division operator by 2 to the power <em>s</em>).</p>
<p>The value of <em>n</em> &gt;&gt;&gt; <em>s</em> is <em>n</em> right-shifted by <em>s</em> bit positions with
zero-extension, where:</p>
<ul class="simple">
<li><p>If <em>n</em> is positive, then the result is the same as that of <em>n</em> &gt;&gt; <em>s</em>.</p></li>
<li><p>If <em>n</em> is negative, and the type of the left-hand operand is <em>int</em>, then
the result is equal to that of the expression (<em>n</em> &gt;&gt; <em>s</em>) + (<em>2</em> &lt;&lt; <em>s</em>).</p></li>
<li><p>If <em>n</em> is negative, and the type of the left-hand operand is <em>long</em>, then
the result is equal to that of the expression (<em>n</em> &gt;&gt; <em>s</em>) + (<em>2L</em> &lt;&lt; <em>s</em>).</p></li>
</ul>
<div class="line-block" id="index-106">
<div class="line"><br /></div>
</div>
</section>
<section id="relational-expressions">
<span id="id57"></span><h2><span class="section-number">7.24. </span>Relational Expressions<a class="headerlink" href="#relational-expressions" title="Permalink to this heading">¶</a></h2>
<p>Relational expressions use <em>relational operators</em> ‘&lt;’, ‘&gt;’, ‘&lt;=’, and ‘&gt;=’.</p>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">relationalExpression</span>:
<span class="w">    </span><span class="nc">expression</span><span class="w"> </span>&#39;&lt;&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">expression</span><span class="w"> </span>&#39;&gt;&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">expression</span><span class="w"> </span>&#39;&lt;<span class="o">=</span>&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">expression</span><span class="w"> </span>&#39;&gt;<span class="o">=</span>&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>The relational operators group left-to-right.</p>
<p>A relational expression is always of type <em>boolean</em>.</p>
<p>Two kinds of relational expressions are described below. The kind of a
relational expression depends on the types of operands. It is a compile time
error if at leats one type of operands is different from types described below.</p>
<div class="line-block" id="index-107">
<div class="line"><br /></div>
</div>
<section id="numerical-comparison-operators-and">
<span id="numerical-comparison-operators"></span><h3><span class="section-number">7.24.1. </span>Numerical Comparison Operators &lt;, &lt;=, &gt;, and &gt;=<a class="headerlink" href="#numerical-comparison-operators-and" title="Permalink to this heading">¶</a></h3>
<p>The type of each operand in a numerical comparison operator must be convertible
(see <a class="reference internal" href="6_conversions.html#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a>) to a numeric type. Otherwise, a compile-time
error occurs.</p>
<p>Numeric types conversions (see <a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a>) are
performed on each operand as follows:</p>
<ul class="simple">
<li><p>Signed integer comparison if the converted type of the operand is
<em>int</em> or <em>long</em>.</p></li>
<li><p>Floating-point comparison if the converted type of the operand is
<em>float</em> or <em>double</em>.</p></li>
</ul>
<p id="index-108">The comparison of floating-point values drawn from any value set must be accurate.</p>
<p>A floating-point comparison must be performed in accordance with the IEEE 754
standard specification as follows:</p>
<ul class="simple">
<li><p>The result of a floating-point comparison is false if either operand is NaN.</p></li>
<li><p>All values other than NaN must be ordered with the following:</p>
<ul>
<li><p>Negative infinity less than all finite values; and</p></li>
<li><p>Positive infinity greater than all finite values.</p></li>
</ul>
</li>
<li><p>Positive zero equals negative zero.</p></li>
</ul>
<p id="index-109">Based on the above presumption, the following rules apply to integer operands,
or floating-point operands other than NaN:</p>
<ul class="simple">
<li><p>The value produced by the operator ‘&lt;’ is <em>true</em> if the value of the
left-hand operand is less than that of the right-hand operand. Otherwise,
the value is <em>false</em>.</p></li>
<li><p>The value produced by the operator ‘&lt;=’ is <em>true</em> if the value of the
left-hand operand is less than or equal to that of the right-hand operand.
Otherwise, the value is <em>false</em>.</p></li>
<li><p>The value produced by the operator ‘&gt;’ is <em>true</em> if the value of the
left-hand operand is greater than that of the right-hand operand. Otherwise,
the value is <em>false</em>.</p></li>
<li><p>The value produced by the operator ‘&gt;=’ is <em>true</em> if the value of the
left-hand operand is greater than or equal to that of the right-hand operand.
Otherwise, the value is <em>false</em>.</p></li>
</ul>
</section>
<section id="string-comparison-operators-and">
<span id="string-comparison-operators"></span><span id="index-110"></span><h3><span class="section-number">7.24.2. </span>String Comparison Operators &lt;, &lt;=, &gt;, and &gt;=<a class="headerlink" href="#string-comparison-operators-and" title="Permalink to this heading">¶</a></h3>
<p>Results of all string comparisons are defined as follows:</p>
<ul class="simple">
<li><p>The operator ‘&lt;’ delivers <em>true</em> if the string value of the left-hand
operand is lexicographically less than the string value of the right-hand
operand, or <em>false</em> otherwise.</p></li>
<li><p>The operator ‘&lt;=’ delivers <em>true</em> if the string value of the left-hand
operand is lexicographically less or equal than the string value of the
right-hand operand, or <em>false</em> otherwise.</p></li>
<li><p>The operator ‘&gt;’ delivers <em>true</em> if the string value of the left-hand
operand is lexicographically greater than the string value of the right-hand
operand, or <em>false</em> otherwise.</p></li>
<li><p>The operator ‘&gt;=’ delivers <em>true</em> if the string value of the left-hand
operand is lexicographically greater or equal than the string value of the
right-hand operand, or <em>false</em> otherwise.</p></li>
</ul>
</section>
<section id="boolean-comparison-operators-and">
<span id="boolean-comparison-operators"></span><span id="index-111"></span><h3><span class="section-number">7.24.3. </span>Boolean Comparison Operators &lt;, &lt;=, &gt;, and &gt;=<a class="headerlink" href="#boolean-comparison-operators-and" title="Permalink to this heading">¶</a></h3>
<p>Results of all boolean comparisons are defined as follows:</p>
<ul class="simple">
<li><p>The operator ‘&lt;’ delivers <em>true</em> if the left-hand operand is <em>false</em> and
the right-hand operand is true, or <em>false</em> otherwise.</p></li>
<li><p>The operator ‘&lt;=’ delivers <em>true</em> if the left-hand operand is <em>false</em> and
the right-hand operand is <em>true</em> or <em>false</em>, or <em>false</em> otherwise.</p></li>
<li><p>The operator ‘&gt;’ delivers <em>true</em> if the left-hand operand is <em>true</em> and
the right-hand operand is <em>false</em>, or <em>false</em> otherwise.</p></li>
<li><p>The operator ‘&gt;=’ delivers <em>true</em> if the left-hand operand is <em>true</em> and
the right-hand operand is <em>false</em> or <em>true</em>, or <em>false</em> otherwise.</p></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
</section>
<section id="equality-expressions">
<span id="id58"></span><h2><span class="section-number">7.25. </span>Equality Expressions<a class="headerlink" href="#equality-expressions" title="Permalink to this heading">¶</a></h2>
<p>Equality expressions use <em>equality operators</em> ‘==’, ‘===’, ‘!=’, and ‘!==’:</p>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">equalityExpression</span>:
<span class="w">    </span><span class="nc">expression</span><span class="w"> </span><span class="p">(</span>&#39;<span class="o">==</span>&#39;<span class="w"> </span>|<span class="w"> </span>&#39;<span class="o">===</span>&#39;<span class="w"> </span>|<span class="w"> </span>&#39;!<span class="o">=</span>&#39;<span class="w"> </span>|<span class="w"> </span>&#39;!<span class="o">==</span>&#39;<span class="p">)</span><span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>Any equality expression is of type <em>boolean</em>. The result of operators <code class="docutils literal notranslate"><span class="pre">==</span></code>
and <code class="docutils literal notranslate"><span class="pre">===</span></code> is <em>true</em> if operands are <em>equal</em> (see below). Otherwise, the
result is <em>false</em>.</p>
<p>In all cases, <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></code> produces the same result as <code class="docutils literal notranslate"><span class="pre">!(a</span> <span class="pre">==</span> <span class="pre">b)</span></code>, and
<code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">!==</span> <span class="pre">b</span></code> produces the same result as <code class="docutils literal notranslate"><span class="pre">!(a</span> <span class="pre">===</span> <span class="pre">b)</span></code>.</p>
<p>Equality operators group left-to-right.
Equality operators are commutative if operand expressions cause no side
effects.</p>
<p>Equality operators are similar to relational operators, except for their
lower precedence (<span class="math notranslate nohighlight">\(a &lt; b==c &lt; d\)</span> is <em>true</em> if both <span class="math notranslate nohighlight">\(a &lt; b\)</span>
and <span class="math notranslate nohighlight">\(c &lt; d\)</span> have the same <em>truth</em> value).</p>
<p>The choice of <em>value equality</em> or <em>reference equality</em> depends on the
equality operator and the types of operands used:</p>
<ul class="simple">
<li><p><em>value equality</em> is applied to entities of primitive types, their boxed
versions, and strings.</p></li>
<li><p><em>reference equality</em> is applied to entities of reference types.</p></li>
</ul>
<p>For operators <code class="docutils literal notranslate"><span class="pre">===</span></code> and <cite>!==</cite>, <a class="reference internal" href="#reference-equality"><span class="std std-ref">Reference Equality</span></a> is used if both
operands are of reference types. Otherwise, a compile-time error occurs.</p>
<p>For operators <code class="docutils literal notranslate"><span class="pre">==</span></code> and <cite>!=</cite>, the following is used:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#value-equality-for-numeric-types"><span class="std std-ref">Value Equality for Numeric Types</span></a> if operands are of numeric types
or boxed version of numeric types;</p></li>
<li><p><a class="reference internal" href="#value-equality-for-booleans"><span class="std std-ref">Value Equality for Booleans</span></a> if both operands are of type <em>boolean</em>
or <em>Boolean</em>;</p></li>
<li><p><a class="reference internal" href="#value-equality-for-characters"><span class="std std-ref">Value Equality for Characters</span></a> if both operands are of type <em>char</em>
or <em>Char</em>;</p></li>
<li><p><a class="reference internal" href="#value-equality-for-strings"><span class="std std-ref">Value Equality for Strings</span></a> if both operands are of type <em>string</em>;</p></li>
<li><p><a class="reference internal" href="#equality-with-null-or-undefined"><span class="std std-ref">Equality with null or undefined</span></a> if one operand is <em>null</em> or
<em>undefined</em>;</p></li>
<li><p><a class="reference internal" href="#reference-equality"><span class="std std-ref">Reference Equality</span></a> if both operands are of compatible reference types;</p></li>
<li><p>Otherwise, a compile-time error occurs.</p></li>
</ul>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="c1">// Entities of value types are not comparable between each other</span>
<span class="linenos">2</span><span class="mf">5</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">&quot;5&quot;</span><span class="w"> </span><span class="c1">// compile-time error</span>
<span class="linenos">3</span><span class="mf">5</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c1">// compile-time error</span>
<span class="linenos">4</span><span class="s2">&quot;5&quot;</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span><span class="c1">// compile-time error</span>
</pre></div>
</div>
<section id="value-equality-for-numeric-types">
<span id="index-112"></span><span id="id59"></span><h3><span class="section-number">7.25.1. </span>Value Equality for Numeric Types<a class="headerlink" href="#value-equality-for-numeric-types" title="Permalink to this heading">¶</a></h3>
<p>The numeric types conversion (see <a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a>)
is performed on the operands of a value equality operator if
each operand is of a numeric type or the boxed version of a numeric type.</p>
<p>If the converted type of the operands is <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">long</span></code>, then an
integer equality test is performed.</p>
<p>If the converted type is <em>float</em> or <em>double</em>, then a floating-point equality
test is performed.</p>
<p>The floating-point equality test must be performed in accordance with the
following IEEE 754 standard rules:</p>
<ul id="index-113">
<li><p>The result of ‘<span class="math notranslate nohighlight">\(==\)</span>’ is <em>false</em> but the result of ‘<span class="math notranslate nohighlight">\(!=\)</span>’ is
<em>true</em> if either operand is NaN.</p>
<p>The test <span class="math notranslate nohighlight">\(x != x\)</span> is <em>true</em> only if <em>x</em> is NaN.</p>
</li>
<li><p>Positive zero equals negative zero.</p></li>
<li><p>The equality operators consider two distinct floating-point values unequal
in any other situation.</p>
<p>For example, if one value represents positive infinity, and the other
represents negative infinity, then each compares equal to itself and
unequal to all other values.</p>
</li>
</ul>
<p>Based on the above presumptions, the following rules apply to integer operands
or floating-point operands other than NaN:</p>
<ul class="simple">
<li><p>If the value of the left-hand operand is equal to that of the right-hand
operand, then the operator ‘<span class="math notranslate nohighlight">\(==\)</span>’ produces the value <em>true</em>.
Otherwise, the result is <em>false</em>.</p></li>
<li><p>If the value of the left-hand operand is not equal to that of the right-hand
operand, then the operator ‘<span class="math notranslate nohighlight">\(!=\)</span>’ produces the value <em>true</em>.
Otherwise, the result is <em>false</em>.</p></li>
</ul>
<p>The following example illustrates <em>value equality</em>:</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="mf">5</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">5</span><span class="w"> </span><span class="c1">// true</span>
<span class="linenos"> 2</span><span class="mf">5</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mf">5</span><span class="w"> </span><span class="c1">// false</span>
<span class="linenos"> 3</span>
<span class="linenos"> 4</span><span class="mf">5</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">5</span><span class="w"> </span><span class="c1">// compile-time error</span>
<span class="linenos"> 5</span>
<span class="linenos"> 6</span><span class="mf">5</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Number</span><span class="p">(</span><span class="mf">5</span><span class="p">)</span><span class="w"> </span><span class="c1">// true</span>
<span class="linenos"> 7</span><span class="mf">5</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Number</span><span class="p">(</span><span class="mf">5</span><span class="p">)</span><span class="w"> </span><span class="c1">// compile-time error</span>
<span class="linenos"> 8</span>
<span class="linenos"> 9</span><span class="ow">new</span><span class="w"> </span><span class="nb">Number</span><span class="p">(</span><span class="mf">5</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Number</span><span class="p">(</span><span class="mf">5</span><span class="p">)</span><span class="w"> </span><span class="c1">// true</span>
<span class="linenos">10</span><span class="mf">5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.0</span><span class="w"> </span><span class="c1">// true</span>
</pre></div>
</div>
<div class="line-block" id="index-114">
<div class="line"><br /></div>
</div>
</section>
<section id="value-equality-for-strings">
<span id="id60"></span><h3><span class="section-number">7.25.2. </span>Value Equality for Strings<a class="headerlink" href="#value-equality-for-strings" title="Permalink to this heading">¶</a></h3>
<p>Two strings are equal if they represent the same sequence of characters:</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="s2">&quot;abc&quot;</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">&quot;abc&quot;</span><span class="w"> </span><span class="c1">// true</span>
<span class="linenos">2</span>
<span class="linenos">3</span><span class="kd">function</span><span class="w"> </span><span class="nx">foo</span><span class="p">(</span><span class="nx">s</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">4</span><span class="w">   </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">&quot;hello&quot;</span><span class="p">)</span>
<span class="linenos">5</span><span class="p">}</span>
<span class="linenos">6</span><span class="nx">foo</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)</span><span class="w"> </span><span class="c1">// prints &quot;true&quot;</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="value-equality-for-booleans">
<span id="id61"></span><h3><span class="section-number">7.25.3. </span>Value Equality for Booleans<a class="headerlink" href="#value-equality-for-booleans" title="Permalink to this heading">¶</a></h3>
<p>The operation is a <em>boolean equality</em> if each operand is of type <em>boolean</em> or
<em>Boolean</em>.</p>
<p>Boolean equality operators are associative.</p>
<p>If an operand is of type <em>Boolean</em>, then the unboxing conversion must be
performed (see <a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a>).</p>
<p>If both operands (after the unboxing conversion is performed if required)
are either <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code>, then the result of ‘<span class="math notranslate nohighlight">\(==\)</span>’ is <em>true</em>.
Otherwise, the result is <em>false</em>.</p>
<p>If both operands are either <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code>, then the result of
‘<span class="math notranslate nohighlight">\(!=\)</span>’ is <em>false</em>. Otherwise, the result is <em>true</em>.</p>
<div class="line-block" id="index-115">
<div class="line"><br /></div>
</div>
</section>
<section id="value-equality-for-characters">
<span id="id62"></span><h3><span class="section-number">7.25.4. </span>Value Equality for Characters<a class="headerlink" href="#value-equality-for-characters" title="Permalink to this heading">¶</a></h3>
<p>The operation is a <em>character equality</em> if each operand is of type <em>char</em> or
<em>Char</em>.</p>
<p>Character equality operators are associative.</p>
<p>If an operand is of type <em>Char</em>, then the unboxing conversion must be performed
(see <a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a>).</p>
<p>If both operands (after the unboxing conversion is performed if required)
contain the same character code, then the result of ‘<span class="math notranslate nohighlight">\(==\)</span>’ is <em>true</em>.
Otherwise, the result is <em>false</em>.</p>
<p>If both operands contain different character codes, then the result
of ‘<span class="math notranslate nohighlight">\(!=\)</span>’ is <em>false</em>. Otherwise, the result is <em>true</em>.</p>
<div class="line-block" id="index-116">
<div class="line"><br /></div>
</div>
</section>
<section id="equality-with-null-or-undefined">
<span id="id63"></span><h3><span class="section-number">7.25.5. </span>Equality with <em>null</em> or <em>undefined</em><a class="headerlink" href="#equality-with-null-or-undefined" title="Permalink to this heading">¶</a></h3>
<p>Any entity can be compared to <em>null</em> by using the operators <code class="docutils literal notranslate"><span class="pre">==</span></code> and <code class="docutils literal notranslate"><span class="pre">!=</span></code>.
This comparison can return <em>true</em> only for the entities of <em>nullable</em> types
if they actually have the <em>null</em> value during the program execution. It must
be known during the compilation if other kinds of tests return <em>false</em>.</p>
<p>Similarly, a comparison to <em>undefined</em> produces <em>false</em> unless the variable
being compared is of type <em>undefined</em>, or of a union type that has <em>undefined</em>
as one of its types.</p>
<p id="index-117">The following comparisons evaluate to <em>false</em> at compile time:</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="mf">5</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="c1">// false</span>
<span class="linenos">2</span><span class="mf">5</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">undefined</span><span class="w"> </span><span class="c1">// false</span>
<span class="linenos">3</span><span class="p">(()</span><span class="o">:</span><span class="w"> </span><span class="ow">void</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{})</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="c1">// false</span>
<span class="linenos">4</span>
<span class="linenos">5</span><span class="kd">class</span><span class="w"> </span><span class="nx">X</span><span class="w"> </span><span class="p">{}</span>
<span class="linenos">6</span><span class="ow">new</span><span class="w"> </span><span class="nx">X</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="c1">// false</span>
</pre></div>
</div>
<p>The following comparison is evaluated at runtime:</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kc">undefined</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">2</span><span class="w">     </span><span class="k">return</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">undefined</span>
<span class="linenos">3</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="reference-equality">
<span id="id64"></span><h3><span class="section-number">7.25.6. </span>Reference Equality<a class="headerlink" href="#reference-equality" title="Permalink to this heading">¶</a></h3>
<p>The reference equality compares two reference type operands.</p>
<p>A compile-time error occurs if:</p>
<ul class="simple">
<li><p>Any operand is not of a reference type.</p></li>
<li><p>There is no implicit conversion (see <a class="reference internal" href="6_conversions.html#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a>) that
can convert the type of either operand to the type of the other.</p></li>
</ul>
<p>The result of ‘<span class="math notranslate nohighlight">\(==\)</span>’ or ‘<span class="math notranslate nohighlight">\(===\)</span>’ is <em>true</em> if both operand values:</p>
<ul class="simple">
<li><p>Are <code class="docutils literal notranslate"><span class="pre">null</span></code>;</p></li>
<li><p>Are <code class="docutils literal notranslate"><span class="pre">undefined</span></code>; or</p></li>
<li><p>Refer to the same object, array, or function.</p></li>
</ul>
<p>Otherwise, the result is <em>false</em>.</p>
<p id="index-118">This semantics is illustrated by the following example:</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="kd">class</span><span class="w"> </span><span class="nx">X</span><span class="w"> </span><span class="p">{}</span>
<span class="linenos"> 2</span><span class="ow">new</span><span class="w"> </span><span class="nx">X</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">X</span><span class="p">()</span><span class="w"> </span><span class="c1">// false, two different object of class X</span>
<span class="linenos"> 3</span><span class="ow">new</span><span class="w"> </span><span class="nx">X</span><span class="p">()</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">X</span><span class="p">()</span><span class="w"> </span><span class="c1">// false, the same</span>
<span class="linenos"> 4</span><span class="kd">let</span><span class="w"> </span><span class="nx">x1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">X</span><span class="p">()</span>
<span class="linenos"> 5</span><span class="kd">let</span><span class="w"> </span><span class="nx">x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">x1</span>
<span class="linenos"> 6</span><span class="nx">x1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">x2</span><span class="w"> </span><span class="c1">// true, as x1 and x2 refer to the same object</span>
<span class="linenos"> 7</span><span class="nx">x1</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nx">x2</span><span class="w"> </span><span class="c1">// true, the same</span>
<span class="linenos"> 8</span>
<span class="linenos"> 9</span><span class="ow">new</span><span class="w"> </span><span class="nb">Number</span><span class="p">(</span><span class="mf">5</span><span class="p">)</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Number</span><span class="p">(</span><span class="mf">5</span><span class="p">)</span><span class="w"> </span><span class="c1">// false, different objects</span>
<span class="linenos">10</span>
<span class="linenos">11</span><span class="ow">new</span><span class="w"> </span><span class="nb">Number</span><span class="p">(</span><span class="mf">5</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Number</span><span class="p">(</span><span class="mf">5</span><span class="p">)</span><span class="w"> </span><span class="c1">// true, value equality is used</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
</section>
<section id="bitwise-and-logical-expressions">
<span id="id65"></span><h2><span class="section-number">7.26. </span>Bitwise and Logical Expressions<a class="headerlink" href="#bitwise-and-logical-expressions" title="Permalink to this heading">¶</a></h2>
<p>The <em>bitwise operators</em> and <em>logical operators</em> are as follows:</p>
<ul class="simple">
<li><p>AND operator ‘&amp;’;</p></li>
<li><p>Exclusive OR operator ‘^’; and</p></li>
<li><p>Inclusive OR operator ‘|’.</p></li>
</ul>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">bitwiseAndLogicalExpression</span>:
<span class="w">    </span><span class="nc">expression</span><span class="w"> </span>&#39;&amp;&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">expression</span><span class="w"> </span>&#39;^&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span>|<span class="w"> </span><span class="nc">expression</span><span class="w"> </span>&#39;|&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>These operators have different precedence. The operator ‘&amp;’ has the highest,
and ‘<span class="math notranslate nohighlight">\(|\)</span>’ has the lowest precedence.</p>
<p>The operators group left-to-right. Each operator is commutative, if the
operand expressions have no side effects, and associative.</p>
<p>The bitwise and logical operators can compare two operands of a numeric
type, or two operands of the <em>boolean</em> type. Otherwise, a compile-time error
occurs.</p>
<div class="line-block" id="index-119">
<div class="line"><br /></div>
</div>
<section id="integer-bitwise-operators-and">
<span id="integer-bitwise-operators"></span><h3><span class="section-number">7.26.1. </span>Integer Bitwise Operators &amp;, ^, and |<a class="headerlink" href="#integer-bitwise-operators-and" title="Permalink to this heading">¶</a></h3>
<p>The numeric types conversion (see <a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a>)
is first performed on the operands of an operator ‘&amp;’, ‘^’, or ‘|’ if both
operands are of a type convertible (see <a class="reference internal" href="6_conversions.html#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a>) to a
primitive integer type.</p>
<p><strong>Note</strong>: If the initial type of one or both operands is <code class="docutils literal notranslate"><span class="pre">double</span></code> or
<code class="docutils literal notranslate"><span class="pre">float</span></code>, then that operand or operands are first truncated to the appropriate
integer type. If both operands are of type <em>bigint</em>, then no conversion is
required.</p>
<p>A bitwise operator expression type is the converted type of its operands.</p>
<p>The resultant value of ‘&amp;’ is the bitwise AND of the operand values.</p>
<p>The resultant value of ‘^’ is the bitwise exclusive OR of the operand values.</p>
<p>The resultant value of ‘|’ is the bitwise inclusive OR of the operand values.</p>
<div class="line-block" id="index-120">
<div class="line"><br /></div>
</div>
</section>
<section id="boolean-logical-operators-and">
<span id="boolean-logical-operators"></span><h3><span class="section-number">7.26.2. </span>Boolean Logical Operators &amp;, ^, and |<a class="headerlink" href="#boolean-logical-operators-and" title="Permalink to this heading">¶</a></h3>
<p>The type of the bitwise operator expression is <em>boolean</em> if both operands of a
‘&amp;’, ‘^’, or ‘|’ operator are of type <em>boolean</em> or <em>Boolean</em>. In any case,
the unboxing conversion (see <a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a>) is performed
on the operands if required.</p>
<p>If both operand values are <code class="docutils literal notranslate"><span class="pre">true</span></code>, then the resultant value of ‘&amp;’ is <em>true</em>.
Otherwise, the result is <em>false</em>.</p>
<p>If the operand values are different, then the resultant value of ‘^’ is <em>true</em>.
Otherwise, the result is <em>false</em>.</p>
<p>If both operand values are <code class="docutils literal notranslate"><span class="pre">false</span></code>, then the resultant value of ‘|’ is
<em>false</em>. Otherwise, the result is <em>true</em>.</p>
<div class="line-block" id="index-121">
<div class="line"><br /></div>
</div>
</section>
</section>
<section id="conditional-and-expression">
<span id="id66"></span><h2><span class="section-number">7.27. </span>Conditional-And Expression<a class="headerlink" href="#conditional-and-expression" title="Permalink to this heading">¶</a></h2>
<p>The <em>conditional-and</em> operator ‘&amp;&amp;’ is similar to ‘&amp;’ (see
<a class="reference internal" href="#bitwise-and-logical-expressions"><span class="std std-ref">Bitwise and Logical Expressions</span></a>) but evaluates its right-hand
operand only if the left-hand operand’s value is <em>true</em>.</p>
<p>The computation results of ‘&amp;&amp;’ and ‘&amp;’ on <em>boolean</em> operands are
the same, but the right-hand operand in ‘&amp;&amp;’ can be not evaluated.</p>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">conditionalAndExpression</span>:
<span class="w">    </span><span class="nc">expression</span><span class="w"> </span>&#39;&amp;&amp;&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>The <em>conditional-and</em> operator groups left-to-right.</p>
<p>The <em>conditional-and</em> operator is fully associative as regards both the result
value and side effects (i.e., the evaluations of the expressions <em>((a)</em> &amp;&amp;
<em>(b))</em> &amp;&amp; <em>(c)</em> and <em>(a)</em> &amp;&amp; <em>((b)</em> &amp;&amp; <em>(c))</em> produce the same result, and the
same side effects occur in the same order for any <em>a</em>, <em>b</em>, and <em>c</em>).</p>
<p id="index-122">A <em>conditional-and</em> expression is always of type <em>boolean</em>.</p>
<p>Each operand of the <em>conditional-and</em> operator must be of type <em>boolean</em>, or
<em>Boolean</em>. Otherwise, a compile-time error occurs.</p>
<p>The left-hand operand expression is first evaluated at runtime. If the result
is of type <em>Boolean</em>, then the unboxing conversion (see
<a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a>) is performed as follows:</p>
<ul class="simple">
<li><p>If the resultant value is <em>false</em>, then the value of the <em>conditional-and</em>
expression is <em>false</em>; the evaluation of the right-hand operand expression
is omitted.</p></li>
<li><p>If the value of the left-hand operand is <code class="docutils literal notranslate"><span class="pre">true</span></code>, then the right-hand
expression is evaluated. If the result of the evaluation is of type
<em>Boolean</em>, then the unboxing conversion (see
<a class="reference internal" href="6_conversions.html#primitive-types-conversions"><span class="std std-ref">Primitive Types Conversions</span></a>) is performed. The resultant value is the
value of the <em>conditional-and</em> expression.</p></li>
</ul>
<div class="line-block" id="index-123">
<div class="line"><br /></div>
</div>
</section>
<section id="conditional-or-expression">
<span id="id67"></span><h2><span class="section-number">7.28. </span>Conditional-Or Expression<a class="headerlink" href="#conditional-or-expression" title="Permalink to this heading">¶</a></h2>
<p>The <em>conditional-or</em> operator ‘<span class="math notranslate nohighlight">\(||\)</span>’ is similar to ‘<span class="math notranslate nohighlight">\(|\)</span>’ (see
<a class="reference internal" href="#integer-bitwise-operators"><span class="std std-ref">Integer Bitwise Operators &amp;, ^, and |</span></a>) but evaluates its right-hand operand
only if the value of its left-hand operand is <em>false</em>.</p>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">conditionalOrExpression</span>:
<span class="w">    </span><span class="nc">expression</span><span class="w"> </span>&#39;||&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>The <em>conditional-or</em> operator groups left-to-right.</p>
<p>The <em>conditional-or</em> operator is fully associative as regards both the result
value and side effects (i.e., the evaluations of the expressions <em>((a)</em> ||
<em>(b))</em> || <em>(c)</em> and <em>(a)</em> || <em>((b)</em> || <em>(c))</em> produce the same result,
and the same side effects occur in the same order for any <em>a</em>, <em>b</em>, and <em>c</em>).</p>
<p>A <em>conditional-or</em> expression is always of type <em>boolean</em>.</p>
<p id="index-124">Each operand of the <em>conditional-or</em> operator must be of type <em>boolean</em> or
<em>Boolean</em>. Otherwise, a compile-time error occurs.</p>
<p>The left-hand operand expression is first evaluated at runtime. If the result
is of the <em>Boolean</em> type, then the <em>unboxing conversion ()</em> is performed as
follows:</p>
<ul class="simple">
<li><p>If the resultant value is <em>true</em>, then the value of the <em>conditional-or</em>
expression is <em>true</em>, and the evaluation of the right-hand operand
expression is omitted.</p></li>
<li><p>If the resultant value is <em>false</em>, then the right-hand expression is
evaluated. If the result of the evaluation is of type <em>Boolean</em>, then
the <em>unboxing conversion</em> is performed (see
<a class="reference internal" href="6_conversions.html#unboxing-conversions"><span class="std std-ref">Unboxing Conversions</span></a>). The resultant value is the value of the
<em>conditional-or</em> expression.</p></li>
</ul>
<p>The computation results of ‘||’ and ‘|’ on <em>boolean</em> operands are the same,
but the right-hand operand in ‘||’ can be not evaluated.</p>
<div class="line-block" id="index-125">
<div class="line"><br /></div>
</div>
</section>
<section id="assignment">
<span id="id68"></span><h2><span class="section-number">7.29. </span>Assignment<a class="headerlink" href="#assignment" title="Permalink to this heading">¶</a></h2>
<p>All <em>assignment operators</em> group right-to-left (i.e., <span class="math notranslate nohighlight">\(a=b=c\)</span> means
<span class="math notranslate nohighlight">\(a=(b=c)\)</span>—and thus the value of <em>c</em> is assigned to <em>b</em>, and then
the value of <em>b</em> to <em>a</em>).</p>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">assignmentExpression</span>:
<span class="w">    </span><span class="nc">expression1</span><span class="w"> </span><span class="nc">assignmentOperator</span><span class="w"> </span><span class="nc">expression2</span>
<span class="w">    </span><span class="c1">;</span>

<span class="nc">assignmentOperator</span>
<span class="w">    </span>:<span class="w"> </span>&#39;<span class="o">=</span>&#39;
<span class="w">    </span>|<span class="w"> </span>&#39;+<span class="o">=</span>&#39;<span class="w">  </span>|<span class="w"> </span>&#39;-<span class="o">=</span>&#39;<span class="w">  </span>|<span class="w"> </span>&#39;<span class="o">*=</span>&#39;<span class="w">   </span>|<span class="w"> </span>&#39;<span class="o">=</span>&#39;<span class="w">  </span>|<span class="w"> </span>&#39;%<span class="o">=</span>&#39;
<span class="w">    </span>|<span class="w"> </span>&#39;&lt;&lt;<span class="o">=</span>&#39;<span class="w"> </span>|<span class="w"> </span>&#39;&gt;&gt;<span class="o">=</span>&#39;<span class="w"> </span>|<span class="w"> </span>&#39;&gt;&gt;&gt;<span class="o">=</span>&#39;
<span class="w">    </span>|<span class="w"> </span>&#39;&amp;<span class="o">=</span>&#39;<span class="w">  </span>|<span class="w"> </span>&#39;|<span class="o">=</span>&#39;<span class="w">  </span>|<span class="w"> </span>&#39;^<span class="o">=</span>&#39;
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>The result of the first operand in an assignment operator (represented by
expression1) must be one of the following:</p>
<ul class="simple">
<li><p>A named variable, such as a local variable, or a field of the current
object or class;</p></li>
<li><p>A computed variable resultant from a field access (see
<a class="reference internal" href="#field-access-expressions"><span class="std std-ref">Field Access Expressions</span></a>); or</p></li>
<li><p>An array or record component access (see <a class="reference internal" href="#indexing-expression"><span class="std std-ref">Indexing Expression</span></a>).</p></li>
</ul>
<p id="index-126">A compile-time error occurs if <em>expression1</em> contains the chaining
operator ‘<code class="docutils literal notranslate"><span class="pre">?.</span></code>’ (see <a class="reference internal" href="#chaining-operator"><span class="std std-ref">Chaining Operator</span></a>).</p>
<p>A compile-time error occurs if the result of <em>expression1</em> is not a variable.</p>
<p>The type of the variable is the type of the assignment expression.</p>
<p>The result of the assignment expression at runtime is not itself a variable
but the value of a variable after the assignment.</p>
<div class="line-block" id="index-127">
<div class="line"><br /></div>
</div>
<section id="simple-assignment-operator">
<span id="id69"></span><h3><span class="section-number">7.29.1. </span>Simple Assignment Operator<a class="headerlink" href="#simple-assignment-operator" title="Permalink to this heading">¶</a></h3>
<p>A compile-time error occurs if the type of the right-hand operand
(<em>expression2</em>) is not compatible (see <a class="reference internal" href="15_semantics.html#type-compatibility"><span class="std std-ref">Type Compatibility</span></a>) with
the type of the variable (see <a class="reference internal" href="5_generics.html#generic-parameters"><span class="std std-ref">Generic Parameters</span></a>). Otherwise,
the expression is evaluated at runtime in one of the following ways:</p>
<ol class="arabic simple">
<li><p>If the left-hand operand <em>expression1</em> is a field access expression
<em>e.f</em> (see <a class="reference internal" href="#field-access-expressions"><span class="std std-ref">Field Access Expressions</span></a>), possibly enclosed in a
pair of parentheses, then:</p>
<ol class="arabic simple">
<li><p><em>expression1</em> <em>e</em> is evaluated: if the evaluation of <em>e</em>
completes abruptly, then so does the assignment expression.</p></li>
<li><p>The right-hand operand <em>expression2</em> is evaluated: if the evaluation
completes abruptly, then so does the assignment expression.</p></li>
<li><p>The value of the right-hand operand as computed above is assigned
to the variable denoted by <em>e.f</em>.</p></li>
</ol>
</li>
</ol>
<ol class="arabic" id="index-128" start="2">
<li><p>If the left-hand operand is an array access expression (see
<a class="reference internal" href="#array-indexing-expression"><span class="std std-ref">Array Indexing Expression</span></a>), possibly enclosed in a pair of
parentheses, then:</p>
<ol class="arabic">
<li><p>The array reference subexpression of the left-hand operand is evaluated.
If this evaluation completes abruptly, then so does the assignment
expression. In that case, the right-hand operand and the index
subexpression are not evaluated, and the assignment does not occur.</p></li>
<li><p>If the evaluation completes normally, then the index subexpression of
the left-hand operand is evaluated. If this evaluation completes
abruptly, then so does the assignment expression. In that case, the
right-hand operand is not evaluated, and the assignment does not occur.</p></li>
<li><p>If the evaluation completes normally, then the right-hand operand is
evaluated. If this evaluation completes abruptly, then so does the
assignment expression, and the assignment does not occur.</p></li>
<li><p>If the evaluation completes normally, but the value of the index
subexpression is less than zero, or greater than, or equal to the
<em>length</em> of the array, then <em>ArrayIndexOutOfBoundsError</em> is thrown,
and the assignment does not occur.</p></li>
<li><p>Otherwise, the value of the index subexpression is used to select an
element of the array referred to by the value of the array reference
subexpression.</p>
<p>That element is a variable of type <em>SC</em>. If <em>TC</em> is the type of the
left-hand operand of the assignment operator determined at compile
time, then there are two options:</p>
<ul>
<li><p>If <em>TC</em> is a primitive type, then <em>SC</em> can only be the same as <em>TC</em>.</p>
<p>The value of the right-hand operand is converted to the type of the
selected array element. The value set conversion (see
<a class="reference internal" href="6_conversions.html#implicit-conversions"><span class="std std-ref">Implicit Conversions</span></a>) is performed to convert it to the
appropriate standard value set (not an extended-exponent value set).
The result of the conversion is stored into the array element.</p>
</li>
<li><p>If <em>TC</em> is a reference type, then <em>SC</em> can be the same as <em>TC</em> or
a type that extends or implements <em>TC</em>.</p>
<p>If the ArkTS compiler cannot guarantee at compile time that the array
element is exactly of type <em>TC</em>, then a check must be performed
at runtime to ensure that class <em>RC</em>—i.e., the class of the
object referred to by the value of the right-hand operand at
runtime—is compatible with the actual type <em>SC</em> of the array element
(see <a class="reference internal" href="4_names.html#type-compatibility-with-initializer"><span class="std std-ref">Type Compatibility with Initializer</span></a>).</p>
<p>If class <em>RC</em> is not assignable to type <em>SC</em>, then <em>ArrayStoreError</em>
is thrown, and the assignment does not occur.</p>
<p>Otherwise, the reference value of the right-hand operand is stored in
the selected array element.</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<ol class="arabic simple" id="index-129" start="3">
<li><p>If the left-hand operand is a record access expression (see
<a class="reference internal" href="#record-indexing-expression"><span class="std std-ref">Record Indexing Expression</span></a>), possibly enclosed in a pair of
parentheses, then:</p>
<ol class="arabic simple">
<li><p>The object reference subexpression of the left-hand operand is evaluated.
If this evaluation completes abruptly, then so does the assignment
expression.
In that case, the right-hand operand and the index subexpression are not
evaluated, and the assignment does not occur.</p></li>
<li><p>If the evaluation completes normally, the index subexpression of the
left-hand operand is evaluated. If this evaluation completes abruptly,
then so does the assignment expression.
In that case, the right-hand operand is not evaluated, and the
assignment does not occur.</p></li>
<li><p>If the evaluation completes normally, the right-hand operand is evaluated.
If this evaluation completes abruptly, then so does the assignment
expression.
In that case, the assignment does not occur.</p></li>
<li><p>Otherwise, the value of the index subexpression is used as the <em>key</em>.
In that case, the right-hand operand is used as the <em>value</em>, and the
key-value pair is stored in the record instance.</p></li>
</ol>
</li>
</ol>
<p id="index-130">If none of the above is true, then the following three steps are required:</p>
<ol class="arabic simple">
<li><p>The left-hand operand is evaluated to produce a variable. If the
evaluation completes abruptly, then so does the assignment expression.
In that case, the right-hand operand is not evaluated, and the assignment
does not occur.</p></li>
<li><p>If the evaluation completes normally, then the right-hand operand is
evaluated. If the evaluation completes abruptly, then so does the assignment
expression.
In that case, the assignment does not occur.</p></li>
<li><p>If that evaluation completes normally, then the value of the right-hand
operand is converted to the type of the left-hand variable.
In that case, the result of the conversion is stored into the variable.
A compile-time error occurs if the type of the left-hand variable is
readonly array, while the converted type of the right-hand operand is
a non-readonly array.</p></li>
</ol>
<div class="line-block" id="index-131">
<div class="line"><br /></div>
</div>
</section>
<section id="compound-assignment-operators">
<span id="id70"></span><h3><span class="section-number">7.29.2. </span>Compound Assignment Operators<a class="headerlink" href="#compound-assignment-operators" title="Permalink to this heading">¶</a></h3>
<p>A compound assignment expression in the form <em>E1 op= E2</em> is equivalent to
<em>E1 = ((E1) op (E2)) as T</em>, where <em>T</em> is the type of <em>E1</em>, except that <em>E1</em>
is evaluated only once. This expression can be evaluated at runtime in one
of the following ways:</p>
<ol class="arabic simple">
<li><p>If the left-hand operand expression is not an indexing expression:</p>
<ul class="simple">
<li><p>The left-hand operand is evaluated to produce a variable. If the
evaluation completes abruptly, then so does the assignment expression.
In that case, the right-hand operand is not evaluated, and the
assignment does not occur.</p></li>
<li><p>If the evaluation completes normally, then the value of the left-hand
operand is saved, and the right-hand operand is evaluated. If the
evaluation completes abruptly, then so does the assignment expression.
In that case, the assignment does not occur.</p></li>
<li><p>If the evaluation completes normally, then the saved value of the
left-hand variable, and the value of the right-hand operand are
used to perform the binary operation as indicated by the compound
assignment operator. If the operation completes abruptly, then so
does the assignment expression.
In that case, the assignment does not occur.</p></li>
<li><p>If the evaluation completes normally, then the result of the binary
operation converts to the type of the left-hand variable.
The result of such conversion is stored into the variable.</p></li>
</ul>
</li>
</ol>
<ol class="arabic" id="index-132" start="2">
<li><p>If the left-hand operand expression is an array access expression (see
<a class="reference internal" href="#array-indexing-expression"><span class="std std-ref">Array Indexing Expression</span></a>), then:</p>
<ul>
<li><p>The array reference subexpression of the left-hand operand is
evaluated. If the evaluation completes abruptly, then so does
the assignment expression.
In that case, the right-hand operand and the index subexpression
are not evaluated, and the assignment does not occur.</p></li>
<li><p>If the evaluation completes normally, then the index subexpression
of the left-hand operand is evaluated. If the evaluation completes
abruptly, then so does the assignment expression.
In that case, the right-hand operand is not evaluated, and the
assignment does not occur.</p></li>
<li><p>If the evaluation completes normally, the value of the array
reference subexpression refers to an array, and the value of the
index subexpression is less than zero, greater than, or equal to
the <em>length</em> of the array, then <em>ArrayIndexOutOfBoundsError</em> is
thrown.
In that case, the assignment does not occur.</p></li>
<li><p>If the evaluation completes normally, then the value of the index
subexpression is used to select an array element referred to by
the value of the array reference subexpression. The value of this
element is saved, and then the right-hand operand is evaluated.
If the evaluation completes abruptly, then so does the assignment
expression.
In that case, the assignment does not occur.</p></li>
<li><p>If the evaluation completes normally, consideration must be given
to the saved value of the array element selected in the previous
step. While this element is a variable of type <em>S</em>, and <em>T</em> is
the type of the left-hand operand of the assignment operator
determined at compile time:</p>
<ul>
<li><p>If <em>T</em> is a primitive type, then <em>S</em> is the same as <em>T</em>.</p>
<p>The saved value of the array element, and the value of the right-hand
operand are used to perform the binary operation of the compound
assignment operator.</p>
<p>If this operation completes abruptly, then so does the assignment
expression.
In that case, the assignment does not occur.</p>
<p>If this evaluation completes normally, then the result of the binary
operation converts to the type of the selected array element.
The result of the conversion is stored into the array element.</p>
</li>
<li><p>If <em>T</em> is a reference type, then it must be <em>string</em>.</p>
<p><em>S</em> must also be a <em>string</em> because the class <em>string</em> is the <em>final</em>
class. The saved value of the array element and the value of the
right-hand operand are used to perform the binary operation (string
concatenation) of the compound assignment operator ‘<span class="math notranslate nohighlight">\(+=\)</span>’. If
this operation completes abruptly, then so does the assignment
expression.
In that case, the assignment does not occur.</p>
</li>
<li><p>If the evaluation completes normally, then the <em>string</em> result of
the binary operation is stored into the array element.</p></li>
</ul>
</li>
</ul>
</li>
</ol>
<ol class="arabic" id="index-133" start="3">
<li><p>If the left-hand operand expression is a record access expression (see
<a class="reference internal" href="#record-indexing-expression"><span class="std std-ref">Record Indexing Expression</span></a>):</p>
<ul class="simple">
<li><p>The object reference subexpression of the left-hand operand is
evaluated. If this evaluation completes abruptly, then so does the
assignment expression.
In that case, the right-hand operand and the index subexpression are
not evaluated, and the assignment does not occur.</p></li>
<li><p>If this evaluation completes normally, then the index subexpression of
the left-hand operand is evaluated. If the evaluation completes
abruptly, then so does the assignment expression.
In that case, the right-hand operand is not evaluated, and the
assignment does not occur.</p></li>
<li><p>If this evaluation completes normally, the value of the object
reference subexpression and the value of index subexpression are saved,
then the right-hand operand is evaluated. If the evaluation completes
abruptly, then so does the assignment expression.
In that case, the assignment does not occur.</p></li>
<li><p>If this evaluation completes normally, the saved values of the
object reference subexpression and index subexpression (as the <em>key</em>)
are used to get the <em>value</em> that is mapped to the <em>key</em> (see
<a class="reference internal" href="#record-indexing-expression"><span class="std std-ref">Record Indexing Expression</span></a>), then this <em>value</em> and the value
of the right-hand operand are used to perform the binary operation as
indicated by the compound assignment operator. If the operation
completes abruptly, then so does the assignment expression.
In that case, the assignment does not occur.</p></li>
</ul>
<blockquote>
<div><ul class="simple">
<li><p>If the evaluation completes normally, then the result of the binary
operation is stored as the key-value pair in the record instance
(as in <a class="reference internal" href="#simple-assignment-operator"><span class="std std-ref">Simple Assignment Operator</span></a>).</p></li>
</ul>
</div></blockquote>
</li>
</ol>
<div class="line-block" id="index-134">
<div class="line"><br /></div>
</div>
</section>
</section>
<section id="conditional-expressions">
<span id="id71"></span><h2><span class="section-number">7.30. </span>Conditional Expressions<a class="headerlink" href="#conditional-expressions" title="Permalink to this heading">¶</a></h2>
<p>The conditional expression ‘<span class="math notranslate nohighlight">\(? :\)</span>’ uses the boolean value of the first
expression to decide which of the other two expressions to evaluate:</p>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">conditionalExpression</span>:
<span class="w">    </span><span class="nc">expression</span><span class="w"> </span>&#39;?&#39;<span class="w"> </span><span class="nc">expression</span><span class="w"> </span>&#39;:&#39;<span class="w"> </span><span class="nc">expression</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>The conditional operator ‘<span class="math notranslate nohighlight">\(? :\)</span>’ groups right-to-left (i.e.,
<span class="math notranslate nohighlight">\(a?b:c?d:e?f:g\)</span> and <span class="math notranslate nohighlight">\(a?b:(c?d:(e?f:g))\)</span> have the same meaning).</p>
<p>The conditional operator ‘<span class="math notranslate nohighlight">\(? :\)</span>’ consists of three operand expressions
with the separators ‘<span class="math notranslate nohighlight">\(?\)</span>’ between the first and the second, and
‘<span class="math notranslate nohighlight">\(:\)</span>’ between the second and the third expression.</p>
<p>A compile-time error occurs if the first expression is not of type
<em>boolean</em> or <em>Boolean</em>.</p>
<p>Type of the conditional expression is determined as the union of types of the
second and the third expressions further normalized in accordance with the
process discussed in <a class="reference internal" href="3_types.html#union-types-normalization"><span class="std std-ref">Union Types Normalization</span></a>. If the second and the
third expressions are of the same type, then this is the type of the
conditional expression.</p>
<p>The following steps are performed as the evaluation of a conditional expression
occurs at runtime:</p>
<ol class="arabic simple">
<li><p>The first operand expression of a conditional expression is
evaluated. The unboxing conversion is performed on the result if
necessary. If the unboxing conversion fails, then so does the evaluation
of the conditional expression.</p></li>
<li><p>If the value of the first operand is <code class="docutils literal notranslate"><span class="pre">true</span></code>, then the second operand
expression is evaluated. Otherwise, the third operand expression is
evaluated. The result of successful evaluation is the result of the
conditional expression.</p></li>
</ol>
<p>The examples below represent different scenarios with standalone expressions:</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">class</span><span class="w"> </span><span class="nx">A</span><span class="w"> </span><span class="p">{}</span>
<span class="linenos">2</span><span class="w"> </span><span class="kd">class</span><span class="w"> </span><span class="nx">B</span><span class="w"> </span><span class="k">extends</span><span class="w"> </span><span class="nx">A</span><span class="w"> </span><span class="p">{}</span>
<span class="linenos">3</span>
<span class="linenos">4</span><span class="w"> </span><span class="nx">condition</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">A</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">B</span><span class="p">()</span><span class="w"> </span><span class="c1">// A | B =&gt; A</span>
<span class="linenos">5</span>
<span class="linenos">6</span><span class="w"> </span><span class="nx">condition</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nx">5</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">6</span><span class="w">             </span><span class="c1">// 5 | 6</span>
<span class="linenos">7</span>
<span class="linenos">8</span><span class="w"> </span><span class="nx">condition</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s2">&quot;5&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mf">6</span><span class="w">           </span><span class="c1">// &quot;5&quot; | 6</span>
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="string-interpolation-expressions">
<span id="id72"></span><h2><span class="section-number">7.31. </span>String Interpolation Expressions<a class="headerlink" href="#string-interpolation-expressions" title="Permalink to this heading">¶</a></h2>
<p>A ‘<em>string interpolation expression</em>’ is a template literal (a string literal
delimited with backticks, see <a class="reference internal" href="2_lexical.html#template-literals"><span class="std std-ref">Template Literals</span></a> for details) that
contains at least one <em>embedded expression</em>:</p>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">stringInterpolation</span>:
<span class="w">    </span>&#39;`&#39;<span class="w"> </span><span class="p">(</span><span class="nc">BacktickCharacter</span><span class="w"> </span>|<span class="w"> </span><span class="nc">embeddedExpression</span><span class="p">)</span><span class="o">*</span><span class="w"> </span>&#39;`&#39;
<span class="w">    </span><span class="c1">;</span>

<span class="nc">embeddedExpression</span>:
<span class="w">    </span>&#39;${&#39;<span class="w"> </span><span class="nc">expression</span><span class="w"> </span>&#39;}&#39;
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>An ‘<em>embedded expression</em>’ is an expression specified inside curly braces
preceded by the <em>dollar sign</em> ‘$’. A string interpolation expression is of
type <em>string</em> (see <a class="reference internal" href="3_types.html#string-type"><span class="std std-ref">string Type</span></a>).</p>
<p>When evaluating a <em>string interpolation expression</em>, the result of each
embedded expression substitutes that embedded expression. An embedded
expression must be of type <em>string</em>. Otherwise, the implicit conversion
to <em>string</em> takes place in the same way as with the string concatenation
operator (see <a class="reference internal" href="#string-concatenation"><span class="std std-ref">String Concatenation</span></a>):</p>
<div class="highlight-typescript notranslate" id="index-135"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2</span>
<span class="linenos">2</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2</span>
<span class="linenos">3</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`The result of </span><span class="si">${</span><span class="nx">a</span><span class="si">}</span><span class="sb"> * </span><span class="si">${</span><span class="nx">b</span><span class="si">}</span><span class="sb"> is </span><span class="si">${</span><span class="nx">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">b</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span>
<span class="linenos">4</span><span class="w"> </span><span class="c1">// prints: The result of 2 * 2 is 4</span>
</pre></div>
</div>
<p>The string concatenation operator can be used to rewrite the above example
as follows:</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2</span>
<span class="linenos">2</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2</span>
<span class="linenos">3</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;The result of &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">&quot; * &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">&quot; is &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">b</span><span class="p">)</span>
</pre></div>
</div>
<p>An embedded expression can contain nested template strings.</p>
<div class="line-block" id="index-136">
<div class="line"><br /></div>
</div>
</section>
<section id="lambda-expressions">
<span id="id73"></span><h2><span class="section-number">7.32. </span>Lambda Expressions<a class="headerlink" href="#lambda-expressions" title="Permalink to this heading">¶</a></h2>
<p>‘<em>Lambda expression</em>’ is a short block of code that takes in parameters and
can return a value. <em>Lambda expressions</em> are generally similar to functions,
but do not need names. <em>Lambda expressions</em> can be implemented immediately
within expressions:</p>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">lambdaExpression</span>:
<span class="w">    </span>&#39;<span class="nc">async</span>&#39;?<span class="w"> </span><span class="nc">signature</span><span class="w"> </span>&#39;<span class="o">=</span>&gt;&#39;<span class="w"> </span><span class="nc">lambdaBody</span>
<span class="w">    </span><span class="c1">;</span>

<span class="nc">lambdaBody</span>:
<span class="w">    </span><span class="nc">expression</span><span class="w"> </span>|<span class="w"> </span><span class="nc">block</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">2</span><span class="w"> </span><span class="p">(</span><span class="nx">x</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">sin</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span><span class="w"> </span><span class="c1">// expression as lambda body</span>
</pre></div>
</div>
<p>A <em>lambda expression</em> evaluation:</p>
<ul class="simple">
<li><p>Produces an instance of a function type (see <a class="reference internal" href="3_types.html#function-types"><span class="std std-ref">Function Types</span></a>).</p></li>
<li><p>Does <em>not</em> cause the execution of the expression body. However, the
expression body can be executed later if a function call expression
is used on the produced instance.</p></li>
</ul>
<p>See <a class="reference internal" href="17_experimental.html#throwing-functions"><span class="std std-ref">Throwing Functions</span></a> for the details of ‘<code class="docutils literal notranslate"><span class="pre">throws</span></code>’, and
<a class="reference internal" href="17_experimental.html#rethrowing-functions"><span class="std std-ref">Rethrowing Functions</span></a> for the details of ‘<code class="docutils literal notranslate"><span class="pre">rethrows</span></code>’ marks.</p>
<div class="line-block" id="index-137">
<div class="line"><br /></div>
</div>
<section id="lambda-signature">
<span id="id74"></span><h3><span class="section-number">7.32.1. </span>Lambda Signature<a class="headerlink" href="#lambda-signature" title="Permalink to this heading">¶</a></h3>
<p><em>Lambda signatures</em> are composed of formal parameters and return types of
lambda expressions and function declarations (see <a class="reference internal" href="4_names.html#function-declarations"><span class="std std-ref">Function Declarations</span></a>).
Lambda expressions and function declarations have the same syntax and semantics.</p>
<p>See <a class="reference internal" href="4_names.html#scopes"><span class="std std-ref">Scopes</span></a> for the specification of the scope, and
<a class="reference internal" href="4_names.html#shadowing-parameters"><span class="std std-ref">Shadowing Parameters</span></a> for the shadowing details of formal parameter
declarations.</p>
<p>A compile-time error occurs if a lambda expression declares two formal
parameters with the same name.</p>
<p>As a lambda expression is evaluated, the values of actual argument expressions
initialize the newly created parameter variables of the declared type before
the execution of the lambda body.</p>
<div class="line-block" id="index-138">
<div class="line"><br /></div>
</div>
</section>
<section id="lambda-body">
<span id="id75"></span><h3><span class="section-number">7.32.2. </span>Lambda Body<a class="headerlink" href="#lambda-body" title="Permalink to this heading">¶</a></h3>
<p><em>Lambda body</em> can be a single expression or a block (see <a class="reference internal" href="8_statements.html#block"><span class="std std-ref">Block</span></a>).
Similarly to the body of a method or a function, a lambda body describes the
code to be executed when a lambda call occurs (see
<a class="reference internal" href="#runtime-evaluation-of-lambda-expressions"><span class="std std-ref">Runtime Evaluation of Lambda Expressions</span></a>).</p>
<p>The meanings of names, and of the keywords <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">super</span></code> (along with
the accessibility of the referred declarations) are the same as in the
surrounding context. However, lambda parameters introduce new names.</p>
<p>If a single expression, a <em>lambda body</em> is equivalent to the block
with one return statement that returns that single expression
<em>{ return singleExpression }</em>.</p>
<p>If completing normally, a lambda body block is <em>value-compatible</em>.
A <em>lambda body completing normally</em> means that the statement of the form
<em>return expression</em> is executed.</p>
<p>If any local variable or formal parameter of the surrounding context is
used but not declared in a lambda body, then the local variable or formal
parameter is <em>captured</em> by the lambda.</p>
<p>If an instance member of the surrounding type is used in the lambda body
defined in a method, then <code class="docutils literal notranslate"><span class="pre">this</span></code> is <em>captured</em> by the lambda.</p>
<p>A compile-time error occurs if a local variable is used in a lambda body but
is neither declared in nor assigned before it.</p>
<div class="line-block" id="index-139">
<div class="line"><br /></div>
</div>
</section>
<section id="lambda-expression-type">
<span id="id76"></span><h3><span class="section-number">7.32.3. </span>Lambda Expression Type<a class="headerlink" href="#lambda-expression-type" title="Permalink to this heading">¶</a></h3>
<p>‘<em>Lambda expression type</em>’ is a function type (see <a class="reference internal" href="3_types.html#function-types"><span class="std std-ref">Function Types</span></a>)
that has the following:</p>
<ul class="simple">
<li><p>Lambda parameters (if any) as parameters of the function type; and</p></li>
<li><p>Lambda return type as the return type of the function type.</p></li>
</ul>
<p><strong>Note</strong>: Lambda return type can be inferred from the <em>lambda body</em>.</p>
<div class="line-block" id="index-140">
<div class="line"><br /></div>
</div>
</section>
<section id="runtime-evaluation-of-lambda-expressions">
<span id="id77"></span><h3><span class="section-number">7.32.4. </span>Runtime Evaluation of Lambda Expressions<a class="headerlink" href="#runtime-evaluation-of-lambda-expressions" title="Permalink to this heading">¶</a></h3>
<p>The evaluation of a lambda expression is distinct from the execution of the
lambda body.</p>
<p>If completing normally at runtime, the evaluation of a lambda expression
produces a reference to an object. In that case, it is similar to the evaluation
of a class instance creation expression.</p>
<p>The evaluation of a lambda expression:</p>
<ul class="simple">
<li><p>Allocates and initializes a new instance of a class with the
properties below; or</p></li>
<li><p>Refers to an existing instance of a class with the properties below.</p></li>
</ul>
<p>If the available space is not sufficient for a new instance to be created,
then the evaluation of the lambda expression completes abruptly, and
<em>OutOfMemoryError</em> is thrown.</p>
<p>During a lambda expression evaluation, the captured values of the
lambda expression are saved to the internal state of the lambda.</p>
<table class="docutils align-default" id="index-141">
<thead>
<tr class="row-odd"><th class="head"><p>Source Fragment</p></th>
<th class="head"><p>Output</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w">  </span><span class="kd">function</span><span class="w"> </span><span class="nx">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">2</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="nx">y</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span>
<span class="linenos">3</span><span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">y</span><span class="o">+</span><span class="mf">1</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">4</span><span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">())</span>
<span class="linenos">5</span><span class="w">  </span><span class="p">}</span>
</pre></div>
</div>
</td>
<td><div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<div><p>2</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p>The variable ‘y’ is <em>captured</em> by the lambda.</p>
<p>The captured variable is not a copy of the original variable. If the
value of the variable captured by the lambda changes, then the original
variable is implied to change:</p>
<table class="docutils align-default" id="index-142">
<thead>
<tr class="row-odd"><th class="head"><p>Source Fragment</p></th>
<th class="head"><p>Output</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">2</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">y</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1</span>
<span class="linenos">3</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">y</span><span class="o">++</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">4</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span>
<span class="linenos">5</span><span class="w"> </span><span class="nx">x</span><span class="p">()</span>
<span class="linenos">6</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span>
<span class="linenos">7</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</td>
<td><div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<div><p>1</p>
<p>2</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p>In order to cause the lambdas behave as required, the language implementation
can act as follows:</p>
<ul class="simple">
<li><p>Replace primitive type for the corresponding boxed type (x: int to x: Int)
if the captured variable is of a primitive type;</p></li>
<li><p>Replace the captured variable’s type for a proxy class that contains an
original reference (x: T for x: Proxy&lt;T&gt;; x.ref = original-ref) if that
captured variable is of a non-primitive type.</p></li>
</ul>
<p>If the captured variable is defined as ‘const’, then neither boxing nor
proxying is required.</p>
<p>If the captured formal parameter can be neither boxed nor proxied, then
the implementation can require the addition of a local variable as follows:</p>
<table class="docutils align-default" id="index-143">
<thead>
<tr class="row-odd"><th class="head"><p>Source Code</p></th>
<th class="head"><p>Pseudo Code</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">foo</span><span class="p">(</span><span class="nx">y</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">2</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">y</span><span class="o">+</span><span class="mf">1</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">3</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">())</span>
<span class="linenos">4</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</td>
<td><div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">foo</span><span class="p">(</span><span class="nx">y</span><span class="o">:</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">2</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">y$</span><span class="o">:</span><span class="w"> </span><span class="kt">Int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">y</span>
<span class="linenos">3</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">y$</span><span class="o">+</span><span class="mf">1</span><span class="w"> </span><span class="p">}</span>
<span class="linenos">4</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">())</span>
<span class="linenos">5</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
</section>
<section id="dynamic-import-expression">
<span id="id78"></span><h2><span class="section-number">7.33. </span>Dynamic Import Expression<a class="headerlink" href="#dynamic-import-expression" title="Permalink to this heading">¶</a></h2>
<p><em>Dynamic import expression</em> allows loading a compilation unit asynchronously
and dynamically.</p>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">dynamicImportExpression</span>:
<span class="w">    </span>&#39;<span class="nc">import</span>&#39;<span class="w"> </span>&#39;<span class="p">(</span>&#39;<span class="w"> </span><span class="nc">expression</span><span class="w"> </span>&#39;<span class="p">)</span>&#39;
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>The <em>expression</em> must be of type <em>string</em> that denotes the <em>path</em> to the module
to be loaded.</p>
<p>The result of this expression is <em>Promise&lt;DynamicObject&gt;</em> (see
<a class="reference internal" href="17_experimental.html#the-promise-t-class"><span class="std std-ref">The Promise&lt;T&gt; Class</span></a> and <a class="reference internal" href="3_types.html#dynamicobject-type"><span class="std std-ref">DynamicObject Type</span></a>).</p>
<p>Methods of class <em>Promise</em> can be used to access the loaded unit, or to catch
an error.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="constant-expressions">
<span id="id79"></span><h2><span class="section-number">7.34. </span>Constant Expressions<a class="headerlink" href="#constant-expressions" title="Permalink to this heading">¶</a></h2>
<div class="highlight-abnf notranslate"><div class="highlight"><pre><span></span><span class="nc">constantExpression</span>:
<span class="w">    </span><span class="nc">expression</span>
<span class="w">    </span><span class="c1">;</span>
</pre></div>
</div>
<p>A ‘<em>constant expression</em>’ is an expression that denotes a value of a primitive
type, or a <em>string</em> that completes normally while being composed only of the
following:</p>
<ul class="simple">
<li><p>Literals of a primitive type, and literals of type <em>string</em> (see
<a class="reference internal" href="2_lexical.html#literals"><span class="std std-ref">Literals</span></a>);</p></li>
<li><p>Casts to primitive types, and casts to type <em>string</em> (see
<a class="reference internal" href="#cast-expressions"><span class="std std-ref">Cast Expressions</span></a>);</p></li>
<li><p>Unary operators ‘<span class="math notranslate nohighlight">\(+\)</span>’, ‘<span class="math notranslate nohighlight">\(-\)</span>’, ‘~’, and ‘!’, but not ‘<span class="math notranslate nohighlight">\(++\)</span>’
or ‘<span class="math notranslate nohighlight">\(--\)</span>’ (see <a class="reference internal" href="#unary-plus"><span class="std std-ref">Unary Plus</span></a>, <a class="reference internal" href="#unary-minus"><span class="std std-ref">Unary Minus</span></a>,
<a class="reference internal" href="#prefix-increment"><span class="std std-ref">Prefix Increment</span></a>, and <a class="reference internal" href="#prefix-decrement"><span class="std std-ref">Prefix Decrement</span></a>);</p></li>
<li><p>Multiplicative operators ‘<span class="math notranslate nohighlight">\(*\)</span>’, ‘<span class="math notranslate nohighlight">\(/\)</span>’, and ‘<span class="math notranslate nohighlight">\(\%\)</span>’ (see
<a class="reference internal" href="#multiplicative-expressions"><span class="std std-ref">Multiplicative Expressions</span></a>);</p></li>
<li><p>Additive operators ‘<span class="math notranslate nohighlight">\(+\)</span>’ and ‘<span class="math notranslate nohighlight">\(-\)</span>’ (see <a class="reference internal" href="#additive-expressions"><span class="std std-ref">Additive Expressions</span></a>);</p></li>
<li><p>Shift operators ‘&lt;&lt;’, ‘&gt;&gt;’, and ‘&gt;&gt;&gt;’ (see <a class="reference internal" href="#shift-expressions"><span class="std std-ref">Shift Expressions</span></a>);</p></li>
<li><p>Relational operators ‘&lt;’, ‘&lt;=’, ‘&gt;’, and ‘&gt;=’ (see <a class="reference internal" href="#relational-expressions"><span class="std std-ref">Relational Expressions</span></a>);</p></li>
<li><p>Equality operators ‘<code class="docutils literal notranslate"><span class="pre">==</span></code>’ and ‘<code class="docutils literal notranslate"><span class="pre">!=</span></code>’ (see <a class="reference internal" href="#equality-expressions"><span class="std std-ref">Equality Expressions</span></a>);</p></li>
<li><p>Bitwise and logical operators ‘&amp;’, ‘^’, and ‘|’ (see <a class="reference internal" href="#bitwise-and-logical-expressions"><span class="std std-ref">Bitwise and Logical Expressions</span></a>);</p></li>
<li><p>Conditional-and operator ‘&amp;&amp;’ (see <a class="reference internal" href="#conditional-and-expression"><span class="std std-ref">Conditional-And Expression</span></a>), and
conditional-or operator ‘||’ (see <a class="reference internal" href="#conditional-or-expression"><span class="std std-ref">Conditional-Or Expression</span></a>);</p></li>
<li><p>Ternary conditional operator ‘? :’ (see <a class="reference internal" href="#conditional-expressions"><span class="std std-ref">Conditional Expressions</span></a>);</p></li>
<li><p>Parenthesized expressions (see <a class="reference internal" href="#parenthesized-expression"><span class="std std-ref">Parenthesized Expression</span></a>) that contain
constant expressions;</p></li>
<li><p>Simple names that refer to constant variables;</p></li>
<li><p>Qualified names that have the form <em>typeReference’.’identifier</em>, and refer
to constant variables.</p></li>
</ul>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">ArkTS Specification</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="1_intro.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="2_lexical.html">2. Lexical Elements</a></li>
<li class="toctree-l1"><a class="reference internal" href="3_types.html">3. Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="4_names.html">4. Names, Declarations and Scopes</a></li>
<li class="toctree-l1"><a class="reference internal" href="5_generics.html">5. Generics</a></li>
<li class="toctree-l1"><a class="reference internal" href="6_conversions.html">6. Contexts and Conversions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">7. Expressions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#evaluation-of-expressions">7.1. Evaluation of Expressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#normal-and-abrupt-completion-of-expression-evaluation">7.1.1. Normal and Abrupt Completion of Expression Evaluation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#order-of-expression-evaluation">7.1.2. Order of Expression Evaluation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operator-precedence">7.1.3. Operator Precedence</a></li>
<li class="toctree-l3"><a class="reference internal" href="#evaluation-of-arguments">7.1.4. Evaluation of Arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#evaluation-of-other-expressions">7.1.5. Evaluation of Other Expressions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#literal">7.2. Literal</a></li>
<li class="toctree-l2"><a class="reference internal" href="#qualified-name">7.3. Qualified Name</a></li>
<li class="toctree-l2"><a class="reference internal" href="#array-literal">7.4. Array Literal</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#array-type-inference-from-context">7.4.1. Array Type Inference from Context</a></li>
<li class="toctree-l3"><a class="reference internal" href="#array-type-inference-from-types-of-elements">7.4.2. Array Type Inference from Types of Elements</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#object-literal">7.5. Object Literal</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#object-literal-of-class-type">7.5.1. Object Literal of Class Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="#object-literal-of-interface-type">7.5.2. Object Literal of Interface Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="#object-literal-of-record-type">7.5.3. Object Literal of Record Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="#object-literal-evaluation">7.5.4. Object Literal Evaluation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#spread-expression">7.6. Spread Expression</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parenthesized-expression">7.7. Parenthesized Expression</a></li>
<li class="toctree-l2"><a class="reference internal" href="#this-expression">7.8. <code class="docutils literal notranslate"><span class="pre">this</span></code> Expression</a></li>
<li class="toctree-l2"><a class="reference internal" href="#field-access-expressions">7.9. Field Access Expressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#accessing-current-object-fields">7.9.1. Accessing Current Object Fields</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accessing-superclass-fields">7.9.2. Accessing Superclass Fields</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#method-call-expression">7.10. Method Call Expression</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#step-1-selection-of-type-to-use">7.10.1. Step 1: Selection of Type to Use</a></li>
<li class="toctree-l3"><a class="reference internal" href="#step-2-selection-of-method">7.10.2. Step 2: Selection of Method</a></li>
<li class="toctree-l3"><a class="reference internal" href="#step-3-semantic-correctness-check">7.10.3. Step 3: Semantic Correctness Check</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-or-method-selection">7.10.4. Function or method selection</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#function-call-expression">7.11. Function Call Expression</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#step-1-selection-of-function">7.11.1. Step 1: Selection of Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#step-2-semantic-correctness-check">7.11.2. Step 2: Semantic Correctness Check</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#indexing-expression">7.12. Indexing Expression</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#array-indexing-expression">7.12.1. Array Indexing Expression</a></li>
<li class="toctree-l3"><a class="reference internal" href="#record-indexing-expression">7.12.2. Record Indexing Expression</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#chaining-operator">7.13. Chaining Operator</a></li>
<li class="toctree-l2"><a class="reference internal" href="#new-expressions">7.14. New Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cast-expressions">7.15. Cast Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#instanceof-expression">7.16. InstanceOf Expression</a></li>
<li class="toctree-l2"><a class="reference internal" href="#typeof-expression">7.17. TypeOf Expression</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ensure-not-nullish-expression">7.18. Ensure-Not-Nullish Expression</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nullish-coalescing-expression">7.19. Nullish-Coalescing Expression</a></li>
<li class="toctree-l2"><a class="reference internal" href="#unary-expressions">7.20. Unary Expressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#postfix-increment">7.20.1. Postfix Increment</a></li>
<li class="toctree-l3"><a class="reference internal" href="#postfix-decrement">7.20.2. Postfix Decrement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#prefix-increment">7.20.3. Prefix Increment</a></li>
<li class="toctree-l3"><a class="reference internal" href="#prefix-decrement">7.20.4. Prefix Decrement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unary-plus">7.20.5. Unary Plus</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unary-minus">7.20.6. Unary Minus</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bitwise-complement">7.20.7. Bitwise Complement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#logical-complement">7.20.8. Logical Complement</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#multiplicative-expressions">7.21. Multiplicative Expressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#multiplication">7.21.1. Multiplication</a></li>
<li class="toctree-l3"><a class="reference internal" href="#division">7.21.2. Division</a></li>
<li class="toctree-l3"><a class="reference internal" href="#remainder">7.21.3. Remainder</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#additive-expressions">7.22. Additive Expressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#string-concatenation">7.22.1. String Concatenation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#additive-operators-and-for-numeric-types">7.22.2. Additive Operators ‘+’ and ‘-’ for Numeric Types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#shift-expressions">7.23. Shift Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#relational-expressions">7.24. Relational Expressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#numerical-comparison-operators-and">7.24.1. Numerical Comparison Operators &lt;, &lt;=, &gt;, and &gt;=</a></li>
<li class="toctree-l3"><a class="reference internal" href="#string-comparison-operators-and">7.24.2. String Comparison Operators &lt;, &lt;=, &gt;, and &gt;=</a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolean-comparison-operators-and">7.24.3. Boolean Comparison Operators &lt;, &lt;=, &gt;, and &gt;=</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#equality-expressions">7.25. Equality Expressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#value-equality-for-numeric-types">7.25.1. Value Equality for Numeric Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#value-equality-for-strings">7.25.2. Value Equality for Strings</a></li>
<li class="toctree-l3"><a class="reference internal" href="#value-equality-for-booleans">7.25.3. Value Equality for Booleans</a></li>
<li class="toctree-l3"><a class="reference internal" href="#value-equality-for-characters">7.25.4. Value Equality for Characters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#equality-with-null-or-undefined">7.25.5. Equality with <em>null</em> or <em>undefined</em></a></li>
<li class="toctree-l3"><a class="reference internal" href="#reference-equality">7.25.6. Reference Equality</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#bitwise-and-logical-expressions">7.26. Bitwise and Logical Expressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#integer-bitwise-operators-and">7.26.1. Integer Bitwise Operators &amp;, ^, and |</a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolean-logical-operators-and">7.26.2. Boolean Logical Operators &amp;, ^, and |</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#conditional-and-expression">7.27. Conditional-And Expression</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conditional-or-expression">7.28. Conditional-Or Expression</a></li>
<li class="toctree-l2"><a class="reference internal" href="#assignment">7.29. Assignment</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#simple-assignment-operator">7.29.1. Simple Assignment Operator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compound-assignment-operators">7.29.2. Compound Assignment Operators</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#conditional-expressions">7.30. Conditional Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#string-interpolation-expressions">7.31. String Interpolation Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lambda-expressions">7.32. Lambda Expressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#lambda-signature">7.32.1. Lambda Signature</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lambda-body">7.32.2. Lambda Body</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lambda-expression-type">7.32.3. Lambda Expression Type</a></li>
<li class="toctree-l3"><a class="reference internal" href="#runtime-evaluation-of-lambda-expressions">7.32.4. Runtime Evaluation of Lambda Expressions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dynamic-import-expression">7.33. Dynamic Import Expression</a></li>
<li class="toctree-l2"><a class="reference internal" href="#constant-expressions">7.34. Constant Expressions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="8_statements.html">8. Statements</a></li>
<li class="toctree-l1"><a class="reference internal" href="9_classes.html">9. Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="10_interfaces.html">10. Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="11_enums.html">11. Enumerations</a></li>
<li class="toctree-l1"><a class="reference internal" href="12_errors.html">12. Error Handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="13_modules.html">13. Compilation Units, Packages, and Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="14_ambients.html">14. Ambient Declarations</a></li>
<li class="toctree-l1"><a class="reference internal" href="15_semantics.html">15. Semantic Rules</a></li>
<li class="toctree-l1"><a class="reference internal" href="16_gui.html">16. Support for GUI Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="17_experimental.html">17. Experimental Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="18_stdlib.html">18. Standard Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="19_grammar.html">19. Grammar Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="20_implementation.html">20. Implementation Details</a></li>
<li class="toctree-l1"><a class="reference internal" href="21_TS_compatibility.html">21. ArkTS-TypeScript compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="0_authors.html">22. Contributors</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="6_conversions.html" title="previous chapter"><span class="section-number">6. </span>Contexts and Conversions</a></li>
      <li>Next: <a href="8_statements.html" title="next chapter"><span class="section-number">8. </span>Statements</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021-2023 Huawei Device Co., Ltd..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/7_expressions.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>